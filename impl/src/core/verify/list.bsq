//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

struct entity Vector<T, literal K=Nat> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    __assume_safe private static s_unsafe_get(l: Vector<T, K>, i: Nat): T # vector_unsafe_get

    method size(): Nat {
        return literal(K);
    }

    method empty(): Bool {
        return literal(K) == 0n;
    }

    method front(): T 
        requires release literal(K) != 0n;
    {
        return Vector<T, K>::s_unsafe_get(this, 0n);
    }

    method back(): T 
        requires release literal(K) != 0n;
    {
        return Vector<T, K>::s_unsafe_get(this, literal(K) - 1n);
    }

    method get(i: Nat): T 
        requires release 0n <= i && i < literal(K);
    {
        return Vector<T, K>::s_unsafe_get(this, i);
    }
}

entity List<T> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    __safe private static s_applycheck_pred(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat): List<T> # list_applycheck_pred

    __safe private static s_size(l: List<T>): Nat # list_size
    __safe private static s_empty(l: List<T>): Nat # list_empty
    __assume_safe private static s_unsafe_get(l: List<T>, i: Nat): T # list_unsafe_get

    __safe private static s_concat(l: List<List<T>>): List<T> # list_concat
    __safe private static s_fill(k: Int, val: T): List<T> # list_fill

    __safe private static {when T grounded KeyType} s_findIndexOf_KeyHelper(l: List<T>, val: T, start: Nat, end: Nat): Nat # list_findindexof_keyhelper
    __safe private static {when T grounded KeyType} s_findIndexOfLast_KeyHelper(l: List<T>, val: T, start: Nat, end: Nat): Nat # list) # list_findindexoflast_keyhelper

    __safe private recursive? static s_findIndexOf_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool), start: Nat, end: Nat): Nat # list_findindexof_predicatehelper
    __safe private recursive? static s_findIndexOfNot_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat): Nat # list_findindexofnot_predicatehelper
    __safe private recursive? static s_findIndexOfLast_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat): Nat # list_findindexoflast_predicatehelper
    __safe private recursive? static s_findIndexOfLastNot_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat): Nat # list_findindexoflastnot_predicatehelper

    __safe private recursive? static s_countIf_Helper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat): Nat # list_countif_helper
    __safe private recursive? static s_countIfNot_Helper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat): Nat # list_countifnot_helper

    private static {when T grounded KeyType} findIndexOf_KeyHelper(l: List<T>, val: T, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return end;
        }
        else if (k == 1n) {
            if(List<T>::s_unsafe_get(l, start) === val) {
                return start;
            }
            else {
                return end;
            }
        }
        else if (k == 2n) {
            if(List<T>::s_unsafe_get(l, start) === val) {
                return start;
            }
            else if(List<T>::s_unsafe_get(l, start + 1) === val) {
                return start + 1;
            }
            else {
                return end;
            }
        }
        else {
            return List<T>::s_findIndexOf_KeyHelper(l, val, start, end);
        }
    }

    private static {when T grounded KeyType} findIndexOfLast_KeyHelper(l: List<T>, val: T, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return end;
        }
        else if (k == 1n) {
            if(List<T>::s_unsafe_get(l, end - 1) === val) {
                return end - 1;
            }
            else {
                return end;
            }
        }
        else if (k == 2n) {
            if(List<T>::s_unsafe_get(l, end - 1) === val) {
                return end - 1;
            }
            else if(List<T>::s_unsafe_get(l, end - 2) === val) {
                return end - 2;
            }
            else {
                return end;
            }
        }
        else {
            return List<T>::s_findIndexOfLast_KeyHelper(l, val, start, end);
        }
    }

    private recursive? static findIndexOf_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return end;
        }
        else if (k == 1n) {
            if(p[recursive?](List<T>::s_unsafe_get(l, start))) {
                return start;
            }
            else {
                return nd;
            }
        }
        else if (k == 2n) {
            if(p[recursive?](List<T>::s_unsafe_get(l, start))) {
                return start;
            }
            else if(p[recursive?](List<T>::s_unsafe_get(l, start + 1))) {
                return start + 1;
            }
            else {
                return end;
            }
        }
        else {
            let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

            return List<T>::s_findIndexOf_PredicateHelper(slist, p, start, end);
        }
    }

    private recursive? static findIndexOfNot_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return end;
        }
        else if (k == 1n) {
            if(!p[recursive?](List<T>::s_unsafe_get(l, start))) {
                return start;
            }
            else {
                return nd;
            }
        }
        else if (k == 2n) {
            if(!p[recursive?](List<T>::s_unsafe_get(l, start))) {
                return start;
            }
            else if(!p[recursive?](List<T>::s_unsafe_get(l, start + 1))) {
                return start + 1;
            }
            else {
                return end;
            }
        }
        else {
            let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

            return List<T>::s_findIndexOfNot_PredicateHelper(slist, p, start, end);
        }
    }

    private recursive? static findIndexOfLast_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return end;
        }
        else if (k == 1n) {
            if(p[recursive?](List<T>::s_unsafe_get(l, end - 1))) {
                return end - 1;
            }
            else {
                return end;
            }
        }
        else if (k == 2n) {
            if(p[recursive?](List<T>::s_unsafe_get(l, end - 1))) {
                return end - 1;
            }
            else if(p[recursive?](List<T>::s_unsafe_get(l, end - 2))) {
                return end - 2;
            }
            else {
                return end;
            }
        }
        else {
            let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

            return List<T>::s_findIndexOfLast_PredicateHelper(slist, p, start, end);
        }
    }

    private recursive? static findIndexOfLastNot_PredicateHelper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return end;
        }
        else if (k == 1n) {
            if(!p[recursive?](List<T>::s_unsafe_get(l, end - 1))) {
                return end - 1;
            }
            else {
                return end;
            }
        }
        else if (k == 2n) {
            if(!p[recursive?](List<T>::s_unsafe_get(l, end - 1))) {
                return end - 1;
            }
            else if(!p[recursive?](List<T>::s_unsafe_get(l, end - 2))) {
                return end - 2;
            }
            else {
                return end;
            }
        }
        else {
            let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

            return List<T>::s_findIndexOfLast_PredicateHelper(slist, p, start, end);
        }
    }


    private recursive? static countIf_Helper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return 0n;
        }
        else if (k == 1n) {
            if(p[recursive?](List<T>::s_unsafe_get(l, start))) {
                return 1n;
            }
            else {
                return 0n;
            }
        }
        else if (k == 2n) {
            if(p[recursive?](List<T>::s_unsafe_get(l, start))) {
                if(p[recursive?](List<T>::s_unsafe_get(l, start + 1))) {
                    return 2n;
                }
                else {
                    return 1n;
                }
            }
            
            else {
                if(p[recursive?](List<T>::s_unsafe_get(l, start + 1))) {
                    return 1n;
                }
                else {
                    return 0n;
                }
            }
        }
        else {
            let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

            return List<T>::s_countIf_Helper(slist, p, start, end);
        }
    }

    private recursive? static countIfNot_Helper(l: List<T>, p: recursive? fn(_: T) -> Bool, start: Nat, end: Nat, k: Nat): Nat {
        if(k == 0n) {
            return 0n;
        }
        else if (k == 1n) {
            if(!p[recursive?](List<T>::s_unsafe_get(l, start))) {
                return 1n;
            }
            else {
                return 0n;
            }
        }
        else if (k == 2n) {
            if(!p[recursive?](List<T>::s_unsafe_get(l, start))) {
                if(!p[recursive?](List<T>::s_unsafe_get(l, start + 1))) {
                    return 2n;
                }
                else {
                    return 1n;
                }
            }
            
            else {
                if(!p[recursive?](List<T>::s_unsafe_get(l, start + 1))) {
                    return 1n;
                }
                else {
                    return 0n;
                }
            }
        }
        else {
            let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

            return List<T>::s_countIfNot_Helper(slist, p, start, end);
        }
    }
    xxxx; //count(if) things here and we should add optional named range params to most methods

    ////
    //Public interface
    ////

    static concat(...ll: List<List<T>>): List<T> {
        if(List<List<T>>::s_empty(ll)) {
            return List<T>@{};
        }
        else if(List<List<T>>::s_size(ll) == 1n) {
            return List<List<T>>::s_unsafe_get(this, 0n);
        }
        else if(List<List<T>>::s_size(ll) == 2n) {
            return List<T>::s_append(List<List<T>>::s_unsafe_get(this, 0n), List<List<T>>::s_unsafe_get(this, 1n))
        }
        else {
            return List<T>::s_concat(ll);
        }
    }

    static fill(k: Nat, val: T): List<T> {
        if(k == 0n) {
            return List<T>@{};
        }
        else if (k == 1n) {
            return List<T>@{ val };
        }
         else if (k == 2n) {
            return List<T>@{ val, val };
        }
        else {
            return List<T>::s_fill(k, val);
        }
    }

    private static s_rangeInBounds(l: List<T>, start: Nat, end: Nat): Bool {
        return start <= end && end <= List<T>::s_size(l); 
    }

    method size(): Int {
        return List<T>::s_size(this);
    }

    method empty(): Bool {
        return List<T>::s_empty(this);
    }

    method front(): T 
        requires release List<T>::s_size(this) != 0n;
    {
        return List<T>::s_unsafe_get(this, 0n);
    }

    method frontOrNone(): T? {
        if(List<T>::s_size(this) == 0n) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, 0n);
        }
    }

    method frontOrDefault(d: T): T {
        if(List<T>::s_size(this) == 0n) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, 0n);
        }
    }

    method frontTry(out? v: T): Bool {
        if(List<T>::s_size(this) != 0n) {
            v = List<T>::s_unsafe_get(this, 0n);
            return true;
        }
        else {
            return false;
        }
    }

    method back(): T 
        requires release List<T>::s_size(this) != 0n;
    {
        return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
    }

    method backOrNone(): T? {
        if(List<T>::s_size(this) == 0n) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
        }
    }

    method backOrDefault(d: T): T {
        if(List<T>::s_size(this) == 0n){
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
        }
    }

    method backTry(out? v: T): Bool {
        if(List<T>::s_size(this) != 0n) {
            v = List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
            return true;
        }
        else {
            return false;
        }
    }

    method get(i: Nat): T 
        requires release i < List<T>::s_size(this);
    {
        return List<T>::s_unsafe_get(this, i);
    }

    method getOrNone(i: Nat): T? {
        if(i < List<T>::s_size(this)) {
            return List<T>::s_unsafe_get(this, i);
        }
        else {
            return none;
        }
    }

    method getOrDefault(i: Nat, d: T): T {
        if(i < List<T>::s_size(this)) {
            return List<T>::s_unsafe_get(this, i);
        }
        else {
            return d;
        }
    }

    method getTry(i: Nat, out? v: T): Bool {
        if(i < List<T>::s_size(this)) {
            v = List<T>::s_unsafe_get(this, i);
            return true;
        }
        else {
            return false;
        }
    }

    //method {when T grounded KeyType} toSet(): Set<T> {
    //    return List<T>::s_toset(this);
    //}

    recursive? method single(p: recursive? fn(_: T) -> Bool): T 
        requires release List<T>::s_size(this) != 0n;
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this));
        let lastidx = this.indexOfLast[recursive?](this, p, 0, List<T>::s_size(this));

        check lastidx == idx;
        check idx < List<T>::s_size(this);

        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method singleOrNone(p: recursive? fn(_: T) -> Bool): T? {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this));
        let lastidx = this.indexOfLast[recursive?](this, p, 0, List<T>::s_size(this));

        if(idx != lastidx) {
            return none;
        }
        else {
            if(idx < List<T>::s_size(this)) {
                return List<T>::s_unsafe_get(this, idx);
            }
            else {
                return none;
            }
        }
    }

    recursive? method singleOrDefault(d: T, p: recursive? fn(_: T) -> Bool): T {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this));
        let lastidx = this.indexOfLast[recursive?](this, p, 0, List<T>::s_size(this));

        if(idx != lastidx) {
            return d;
        }
        else {
            if(idx < List<T>::s_size(this)) {
                return List<T>::s_unsafe_get(this, idx);
            }
            else {
                return d;
            }
        }
    }

    recursive? method singleTry(out? v: T, p: recursive? fn(_: T) -> Bool): Bool {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this));
        let lastidx = this.indexOfLast[recursive?](this, p, 0, List<T>::s_size(this));

        if(idx != lastidx) {
            return false;
        }
        else {
            if(idx < List<T>::s_size(this)) {
                v = List<T>::s_unsafe_get(this, idx);
                return true;
            }
            else {
                return false;
            }
        }
    }

    recursive? method allOf(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::findIndexOfNot_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this)) == List<T>::s_size(this);
    }

    recursive? method noneOf(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this)) == List<T>::s_size(this);
    }

    recursive? method someOf(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this)) < List<T>::s_size(this);
    }

    recursive? method allOfNot(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::findIndexOf_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this)) == List<T>::s_size(this);
    }

    recursive? method noneOfNot(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::findIndexOfNot_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this)) == List<T>::s_size(this);
    }

    recursive? method someOfNot(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::findIndexOfNot_PredicateHelper[recursive?](this, p, 0, List<T>::s_size(this)) < List<T>::s_size(this);
    }

    recursive? method countIf(p: recursive? fn(_: T) -> Bool): Int {
        xxxx;
    }

    recursive? method countIfNot(p: recursive? fn(_: T) -> Bool): Int {
        xxxx;
    }

    /////////////////////////////////////////////

    

    private recursive? static s_filter(l: List<T>, p: recursive? fn(_: T) -> Bool): List<T> # list_filter
    private recursive? static s_filterNot(l: List<T>, p: recursive? fn(_: T) -> Bool): List<T> # list_filternot

    __assume_safe private recursive? static s_slice(l: List<T>, start: Nat, end: Nat): List<T> # list_slice

    private recursive? static s_map<U>(l: List<T>, f: recursive? fn(_: T) -> U): List<U> # list_map
    private recursive? static s_mapIndex<U>(l: List<T>, f: recursive? fn(_: T, _: Nat) -> U): List<U> # list_mapindex

    __safe private static s_zip<T, U>(l1: List<T>, l2: List<U>): List<#[T, U]> # list_zip
    __safe private static s_unzipT<T, U>(l: List<#[T, U]>): List<T> # list_unzipt
    __safe private static s_unzipU<T, U>(l: List<#[T, U]>): List<U> # list_unzipu

    __safe private static s_zipIndex(l: List<T>): List<#[Nat, T]> # list_zipindex

    private recursive? static s_join<U>(l: List<T>, ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, U]> # list_join
    private recursive? static s_joinGroup<U>(l: List<T>, ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<#[T, List<U>]> # list_groupjoin

    __safe private static s_append(l1: List<T>, l2: List<T>): List<T> # list_append

    //////Keep going

    

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U): List<U> {
        let res = List<T>::s_map<U>[recursive](this, f);

        _assume Verifier::term_eq(List<T>::s_size(res), List<T>::s_size(this));
        
        check Verifier::forall(limit: Nat, fn(n: Nat) => Verifier::term_eq(f(List<T>::s_unsafe_get(this, n)), List<T>::s_unsafe_get(res, n)));
        //forall is axiomitized over Int/Nat
        //\exists 0 <= n < limit s.t. (= fn(n) ResultErr@Bool(err)) => ResultErr@Bool(err)
        //\exists 0 <= n < limit s.t. !fn(i) => false
        //\forall 0 <= n < limit s.t. fn(i) => true


        return res;
    }

    /////////////////////////////////////////////
}
