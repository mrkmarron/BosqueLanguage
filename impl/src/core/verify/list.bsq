//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity ISequence {
    __safe static size(s: ISequence): Nat # isequence_size
    __assume_safe static get(s: ISequence, n: Nat): Nat # isequence_get
}

struct entity Vector<T, literal K=Nat> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    __assume_safe private static s_unsafe_get(l: Vector<T, K>, i: Nat): T # vector_unsafe_get

    method size(): Nat {
        return literal(K);
    }

    method empty(): Bool {
        return literal(K) == 0n;
    }

    method front(): T 
        requires release literal(K) != 0n;
    {
        return Vector<T, K>::s_unsafe_get(this, 0n);
    }

    method back(): T 
        requires release literal(K) != 0n;
    {
        return Vector<T, K>::s_unsafe_get(this, literal(K) - 1n);
    }

    method get(i: Nat): T 
        requires release 0n <= i && i < literal(K);
    {
        return Vector<T, K>::s_unsafe_get(this, i);
    }
}

entity ListFrom provides Object {
    __safe private static s_fill<T>(k: Int, val: T): List<T> # list_fill

    __safe private static s_rangeOfInt(start: Int, end: Int): List<Int> # list_rangeofint
    __safe private static s_rangeOfNat(start: Nat, end: Nat): List<Nat> # list_rangeofnat

    private static s_zip<T, U>(l1: List<T>, l2: List<U>): List<#[T, U]> # list_zip
    private static s_unzipt<T, U>(l: List<#[T, U]>): List<T> # list_unzipt
    private static s_unzipu<T, U>(l: List<#[T, U]>): List<U> # list_unzipu

    static fill<T=?>(k: Nat, val: T): List<T> {
        return List<T>::s_fill(k, val);
    }

    static int(start: Int, end: Int): List<Int>
        requires release start <= end;
    {
        return ListOf::s_rangeInt(start, end);
    }

    static nat(start: Nat, end: Nat): List<Nat>
        requires release start <= end;
    {
        return ListOf::s_rangeNat(start, end);
    }

    static zip<T=?, U=?>(l1: List<T>, l2: List<U>): List<#[T, U]>
        requires release List<T>::s_size(l1) == List<U>::s_size(l2);
    {
        return ListOf::s_zip<T, U>(l1, l2);
    }

    static unzip<T=?, U=?>(l: List<#[T, U]>): List<T>, List<U> {
        return ListOf::s_unzipt<T, U>(l), ListOf::s_unzipu<T, U>(l);
    }
}

entity List<T> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    private static s_applycheck_pred(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat): List<T> # list_applycheck_pred
    private static s_applycheck_pred_idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat): List<T> # list_applycheck_pred_idx
    private static s_applycheck_binpred<U>(l: List<T>, ol: List<T>, p: recursive? pred(_: T, _: U) -> Bool): List<T>, List<U> # list_applycheck_binpred

    private static s_applycheck_op<U>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> U): # list_applycheck_op
    private static s_applycheck_op_idx<U>(l: List<T>, p: recursive? pred(_: T, _: Nat) -> U): # list_applycheck_op_idx

    private static {when T grounded KeyType} s_hasCheck(l: List<T>, val: T, start: Nat, end: Nat): Bool # list_hascheck
    private recursive? static s_hasPredCheck(l: List<T>, p: recursive? pred(_: T) -> Bool), start: Nat, end: Nat): Bool # list_haspredcheck
    private recursive? static s_hasPredCheck_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool), start: Nat, end: Nat): Bool # list_haspredcheck_idx
    
    private recursive? static s_computeMatchIdxSequence(l: List<T>, p: recursive? pred(_: T) -> Bool), start: Nat, end: Nat): Bool # list_computematchidxsequence
    private recursive? static s_computeMatchIdxSequence_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool), start: Nat, end: Nat): Bool # list_computematchidxsequence_idx
    private static s_computeOfTypeIdxSequence<U>(l: List<T>, start: Nat, end: Nat): Bool # list_computeoftypeidxsequence
    
    __safe private static s_size(l: List<T>): Nat # list_size
    __safe private static s_empty(l: List<T>): Nat # list_empty
    __assume_safe private static s_unsafe_get(l: List<T>, i: Nat): T # list_unsafe_get

    private static s_concat(l: List<List<T>>): List<T> # list_concat

    private static {when T grounded KeyType} s_findIndexOf_KeyHelper(l: List<T>, val: T, start: Nat, end: Nat): Nat # list_findindexof_keyhelper
    private static {when T grounded KeyType} s_findIndexOfLast_KeyHelper(l: List<T>, val: T, start: Nat, end: Nat): Nat # list) # list_findindexoflast_keyhelper

    private recursive? static s_findIndexOf_PredicateHelper(l: List<T>, p: recursive? pred(_: T) -> Bool), start: Nat, end: Nat): Nat # list_findindexof_predicatehelper
    private recursive? static s_findIndexOfLast_PredicateHelper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat): Nat # list_findindexoflast_predicatehelper
    private recursive? static s_findIndexOf_PredicateHelper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool), start: Nat, end: Nat): Nat # list_findindexof_predicatehelper_idx
    private recursive? static s_findIndexOfLast_PredicateHelper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat): Nat # list_findindexoflast_predicatehelper_idx

    private static {when T KeyType} s_count_KeyHelper(l: List<T>, v: T, start: Nat, end: Nat): Nat # list_count_helper

    private recursive? static s_countIf_Helper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat, s: ISequence): Nat # list_countif_helper
    private recursive? static s_countIf_Helper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat, s: ISequence): Nat # list_countif_helper_idx
    
    private recursive? static s_filter_Helper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat, s: ISequence): List<T> # list_filter_helper
    private recursive? static s_filter_Helper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat, s: ISequence): List<T> # list_filter_helper_idx
    
    private static s_filterToType_Helper<U>(l: List<T>, start: Nat, end: Nat): List<U> # list_filtertotype_helper
    private static s_castToType_Helper<U>(l: List<T>, start: Nat, end: Nat): List<U> # list_casttotype_helper

    private static s_slice_Helper(l: List<T>, start: Nat, end: Nat): List<U> # list_slice_helper

    private recursive? static s_map_Helper<U>(l: List<T>, f: recursive? fn(_: T) -> U, start: Nat, end: Nat): List<T> # list_map_helper
    private recursive? static s_map_Helper_Idx<U>(l: List<T>, f: recursive? fn(_: T, _: Nat) -> U, start: Nat, end: Nat): List<T> # list_map_helper_idx

    private recursive? static s_join_Helper<U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<#[T, U]> # list_join_helper
    private recursive? static s_joinGroup_Helper<U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<#[T, List<U>]> # list_joingroup_helper

    private static s_append_Helper(l: List<T>, ol: List<T>): List<T> # list_append_helper

    private recursive? static s_sort_Helper(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> # list_sort_helper

    private recursive? static findIndexOf_PredicateHelper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat): Nat {
        let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck(slist, p, start, end)) {
            return end;
        }
        else {
            return List<T>::s_findIndexOf_PredicateHelper[recursive?](slist, p, start, end);
        }
    }

    private recursive? static findIndexOfLast_PredicateHelper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat): Nat {
        let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck(slist, p, start, end)) {
            return end;
        }
        else {
            return List<T>::s_findIndexOfLast_PredicateHelper[recursive?](slist, p, start, end);
        }
    }

    private recursive? static findIndexOf_PredicateHelper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat): Nat {
        let slist = List<T>::s_applycheck_pred_idx[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck_Idx(slist, p, start, end)) {
            return end;
        }
        else {
            return List<T>::s_findIndexOf_PredicateHelper_Idx[recursive?](slist, p, start, end);
        }
    }

    private recursive? static findIndexOfLast_PredicateHelper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat): Nat {
        let slist = List<T>::s_applycheck_pred_idx[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck_Idx(slist, p, start, end)) {
            return end;
        }
        else {
            return List<T>::s_findIndexOfLast_PredicateHelper_Idx[recursive?](slist, p, start, end);
        }
    }

    private recursive? static countIf_Helper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat): Nat {
        let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck(slist, p, start, end)) {
            return 0n;
        }
        else {
            let mseq = List<T>::s_computeMatchIdxSequence[recursive?](slist, p, start, end);
            return List<T>::s_countIf_Helper[recursive?](slist, p, start, end, mseq);
        }
    }

    private recursive? static countIf_Helper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat): Nat {
        let slist = List<T>::s_applycheck_pred_idx[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck_Idx(slist, p, start, end)) {
            return 0n;
        }
        else {
            let mseq = List<T>::s_computeMatchIdxSequence[recursive?](slist, p, start, end);
            return List<T>::s_countIf_Helper_Idx[recursive?](slist, p, start, end, mseq);
        }
    }

    private recursive? static filter_Helper(l: List<T>, p: recursive? pred(_: T) -> Bool, start: Nat, end: Nat): List<T> {
        let slist = List<T>::s_applycheck_pred[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck(slist, p, start, end)) {
            return List<T>@{};
        }
        else {
            let mseq = List<T>::s_computeMatchIdxSequence[recursive?](slist, p, start, end);
            return List<T>::s_filter_Helper[recursive?](slist, p, start, end, mseq);
        }
    }

    private recursive? static filter_Helper_Idx(l: List<T>, p: recursive? pred(_: T, _: Nat) -> Bool, start: Nat, end: Nat): List<T> {
        let slist = List<T>::s_applycheck_pred_idx[recursive?](l, p, start, end);

        if(!List<T>::s_hasPredCheck_Idx(slist, p, start, end)) {
            return List<T>@{};
        }
        else {
            let mseq = List<T>::s_computeMatchIdxSequence_Idx[recursive?](slist, p, start, end);
            return List<T>::s_filter_Helper_Idx[recursive?](slist, p, start, end, mseq);
        }
    }

    private static filterToType_Helper<U>(l: List<T>, start: Nat, end: Nat): List<U> {
        let mseq = List<T>::s_computeOfTypeIdxSequence<U>(l, start, end);
        return List<T>::s_filterToType_Helper<U>(l, start, end, mseq);
    }

    private static castToType_Helper<U>(l: List<T>, start: Nat, end: Nat): List<U> {
        return List<T>::s_castToType_Helper(l, start, end);
    }

    private recursive? static map_Helper<U>(l: List<T>, f: recursive? fn(_: T) -> U, start: Nat, end: Nat): List<T> {
        let slist = List<T>::s_applycheck_op[recursive?](l, f, start, end);
        return List<T>::s_map_Helper<U>[recursive?](slist, f, start, end);
    }

    private recursive? static map_Helper_Idx<U>(l: List<T>, f: recursive? fn(_: T, _: Nat) -> U, start: Nat, end: Nat): List<T> {
        let slist = List<T>::s_applycheck_op_idx[recursive?](l, f, start, end);
        return List<T>::s_map_Helper_Idx<U>[recursive?](slist, f, start, end);
    }

    private recursive? static join_Helper<U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<#[T, U]> {
        let sl, sol = List<T>::s_applycheck_binpred<U>[recursive?](l, ol, p);
        return List<T>::s_join_Helper<U>[recursive?](sl, sol, p);
    }

    private recursive? static joinGroup_Helper<U>(l: List<T>, ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<#[T, List<U>]> {
        let sl, sol = List<T>::s_applycheck_binpred<U>[recursive?](l, ol, p);
        return List<T>::s_joinGroup_Helper<U>[recursive?](sl, sol, p);
    }

    private recursive? static sort_Helper(l: List<T>, cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        let sl, sol = List<T>::s_applycheck_binpred<T>[recursive?](l, l, p);
        return List<T>::s_sort_Helper[recursive?](sl, sol, p);
    }

    private static s_rangeInBounds(l: List<T>, start: Nat, end: Nat): Bool {
        return start <= end && end <= List<T>::s_size(l); 
    }

    ////
    //Public interface
    ////

    static concat(...ll: List<List<T>>): List<T> {
        return List<T>::s_concat(ll);
    }

    method size(): Int {
        return List<T>::s_size(this);
    }

    method empty(): Bool {
        return List<T>::s_empty(this);
    }

    method front(): T 
        requires release !List<T>::s_empty(this);
    {
        return List<T>::s_unsafe_get(this, 0n);
    }

    method frontOrNone(): T? {
        if(List<T>::s_empty(this)) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, 0n);
        }
    }

    method frontOrDefault(d: T): T {
        if(List<T>::s_empty(this)) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, 0n);
        }
    }

    method frontTry(out? res: T): Bool {
        if(!List<T>::s_empty(this)) {
            res = List<T>::s_unsafe_get(this, 0n);
            return true;
        }
        else {
            return false;
        }
    }

    method back(): T 
        requires release !List<T>::s_empty(this);
    {
        return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
    }

    method backOrNone(): T? {
        if(List<T>::s_empty(this)) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
        }
    }

    method backOrDefault(d: T): T {
        if(List<T>::s_empty(this)){
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
        }
    }

    method backTry(out? res: T): Bool {
        if(!List<T>::s_empty(this)) {
            res = List<T>::s_unsafe_get(this, List<T>::s_size(this) - 1n);
            return true;
        }
        else {
            return false;
        }
    }

    method get(i: Nat): T 
        requires release i < List<T>::s_size(this);
    {
        return List<T>::s_unsafe_get(this, i);
    }

    method getOrNone(i: Nat): T? {
        if(i < List<T>::s_size(this)) {
            return List<T>::s_unsafe_get(this, i);
        }
        else {
            return none;
        }
    }

    method getOrDefault(i: Nat, d: T): T {
        if(i < List<T>::s_size(this)) {
            return List<T>::s_unsafe_get(this, i);
        }
        else {
            return d;
        }
    }

    method getTry(i: Nat, out? res: T): Bool {
        if(i < List<T>::s_size(this)) {
            res = List<T>::s_unsafe_get(this, i);
            return true;
        }
        else {
            return false;
        }
    }

    //method {when T grounded KeyType} toSet(): Set<T> {
    //    return List<T>::s_toset(this);
    //}

    recursive? method single(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        let lastidx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);

        check lastidx == idx;
        check idx < end;

        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method singleOrNone(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T? 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        let lastidx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);

        if((idx != lastidx) | idx == end) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method singleOrDefault(d: T, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        let lastidx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);

        if((idx != lastidx) | (idx == end)) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method singleTry(out? res: T, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        let lastidx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);

        if((idx != lastidx) | (idx == end)) {
            return false;
        }
        else {
            res = List<T>::s_unsafe_get(this, idx);
            return true;
        }
    }

    recursive? method allOf(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return !List<T>::s_hasPredCheck[recursive?](this, !p, start, end);
    }

    recursive? method allOf(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return !List<T>::s_hasPredCheck[recursive?](this, !p, start, end);
    }

    recursive? method noneOf(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return !List<T>::s_hasPredCheck[recursive?](this, p, start, end);
    }

    recursive? method noneOf(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return !List<T>::s_hasPredCheck[recursive?](this, p, start, end);
    }

    recursive? method someOf(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_hasPredCheck[recursive?](this, p, start, end);
    }

    recursive? method someOf(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_hasPredCheck[recursive?](this, p, start, end);
    }

    recursive? method countIf(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::countIf_Helper[recursive?](this, p, start, end);
    }

    recursive? method countIf(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::countIf_Helper_Idx[recursive?](this, p, start, end);
    }

    method {when T grounded KeyType} contains(v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_findIndexOf_KeyHelper(this, v, start, end) != end;
    }

    method {when T grounded KeyType} count(v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Int
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_count_keytype(this, v, start, end);
    }

    //
    //min, max, argmin, argmax, sum, product
    //

    recursive? method find(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        check idx != end;
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method find(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        check idx != end;
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method findOrNone(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findOrNone(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findOrDefault(d: T, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findOrDefault(d: T, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = List<T>::s_unsafe_get(this, idx);
            return true;
        }
    }

    recursive? method findTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = List<T>::s_unsafe_get(this, idx);
            return true;
        }
    }

    recursive? method findLast(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        check idx != end;
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method findLast(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        check idx != end;
        return List<T>::s_unsafe_get(this, idx);
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findLastOrDefault(d: T, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findLastOrDefault(d: T, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): T
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return List<T>::s_unsafe_get(this, idx);
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = List<T>::s_unsafe_get(this, idx);
            return true;
        }
    }

    recursive? method findLastTry(out? res: T, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = List<T>::s_unsafe_get(this, idx);
            return true;
        }
    }

    recursive? method findIndexOf(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        check idx != end;
        return idx;
    }

    recursive? method findIndexOf(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        check idx != end;
        return idx;
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfOrNone(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfOrDefault(d: Nat, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfOrDefault(d: Nat, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        check idx != end;
        return idx;
    }

    recursive? method findIndexOfLast(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        check idx != end;
        return idx;
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfLastOrNone(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfLastOrDefault(d: Nat, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfLastOrDefault(d: Nat, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return idx;
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method findIndexOfLastTry(out? res: Nat, p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::findIndexOfLast_PredicateHelper_Idx[recursive?](this, p, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    method {when T grounded KeyType} indexOf(v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOf_KeyHelper(this, v, start, end);
        check idx != end;
        return idx;
    }

    method {when T grounded KeyType} indexOfOrNone(v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOf_KeyHelper(this, v, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return idx;
        }
    }

    method {when T grounded KeyType} indexOfOrDefault(d: T, v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOf_KeyHelper(this, v, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return idx;
        }
    }

    method {when T grounded KeyType} indexOfTry(out? res: T, v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOf_KeyHelper(this, v, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    method {when T grounded KeyType} indexOfLast(v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOfLast_KeyHelper(this, v, start, end);
        check idx != end;
        return idx;
    }

    method {when T grounded KeyType} indexOfLastOrNone(v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat?
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOfLast_KeyHelper(this, v, start, end);
        if(idx == end) {
            return none;
        }
        else {
            return idx;
        }
    }

    method {when T grounded KeyType} indexOfLastOrDefault(d: T, v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Nat
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOfLast_KeyHelper(this, v, start, end);
        if(idx == end) {
            return d;
        }
        else {
            return idx;
        }
    }

    method {when T grounded KeyType} indexOfLastTry(out? res: T, v: T, start?: Nat=0, end?: Nat=List<T>::s_size(this)): Bool
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let idx = List<T>::s_findIndexOfLast_KeyHelper(this, v, start, end);
        if(idx == end) {
            return false;
        }
        else {
            res = idx;
            return true;
        }
    }

    recursive? method filter(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::filter_Helper[recursive?](this, p, start, end);
    }

    recursive? method filter(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::filter_Helper_Idx[recursive?](this, p, start, end);
    }

    method filterToType<U>(start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<U>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::filterToTypetype_Helper<U>(this, start, end);
    }

    method castToType<U>(start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<U>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::castToType_Helper<U>(this, start, end);
    }

    method slice(start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_slice_Helper(this, s, e);
    }

    method removeFirst(k: Nat): List<T> 
        requires release k <= List<T>::s_size(this);
    {
        return List<T>::s_slice_Helper(this, k, List<T>::s_size(this));
    }

    method removeLast(k: Nat): List<T> 
        requires release k <= List<T>::s_size(this);
    {
        return List<T>::s_slice_Helper(this, 0, List<T>::s_size(this) - k);
    }

    recursive? method takeWhile(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper[recursive?](this, !p, start, end);
        return List<T>::s_slice_Helper(this, 0, lpos);
    }

    recursive? method takeWhile(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, !p, start, end);
        return List<T>::s_slice_Helper(this, 0, lpos);
    }

    recursive? method discardWhile(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper[recursive?](this, !p, start, end);
        return List<T>::s_slice_Helper(this, lpos, end - lpos);
    }

    recursive? method discardWhile(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, !p, start, end);
        return List<T>::s_slice_Helper(this, lpos, end - lpos);
    }

    recursive? method takeUntil(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        return List<T>::s_slice_Helper(this, lpos, end - lpos);
    }

    recursive? method takeUntil(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T>
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        return List<T>::s_slice_Helper(this, lpos, end - lpos);
    }

    recursive? method discardUntil(p: recursive? pred(_: T) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper[recursive?](this, p, start, end);
        return List<T>::s_slice_Helper(this, lpos, end - lpos);
    }

    recursive? method discardUntil(p: recursive? pred(_: T, _: Nat) -> Bool, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<T> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        let lpos = List<T>::findIndexOf_PredicateHelper_Idx[recursive?](this, p, start, end);
        return List<T>::s_slice_Helper(this, lpos, end - lpos);
    }

    //method {when T KeyType} unique(): List<T> {
    //    return List<T>::s_unique(this);
    //}

    //recursive? method uniqueOf(cmp: recursive? fn(_: T, _: T) -> Bool): List<T> {
    //    return List<T>::s_unique(this);
    //}

    //method reverse(): List<T> {
    //    return List<T>::s_reverse(this);
    //}

    recursive? method map<U=?>(f: recursive? fn(_: T) -> U, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<U> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_map_Helper<U>[recursive?](this, f, start, end);
    }

    recursive? method map<U=?>(f: recursive? fn(_: T, _: Nat) -> U, start?: Nat=0, end?: Nat=List<T>::s_size(this)): List<U> 
        requires release List<T>::s_rangeInBounds(this, start, end);
    {
        return List<T>::s_map_Helper_Idx<U>[recursive?](this, f, start, end);
    }

    //
    //Project using Map<K, V> operations
    //

    recursive? method join<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<#[T, U]> {
        return List<T>::s_join_Helper<U>[recursive?](this, ol, p);
    }

    recursive? method joinGroup<U=?>(ol: List<U>, p: recursive? pred(_: T, _: U) -> Bool): List<#[T, List<U>]> {
        return List<T>::s_joinGroup_Helper<U>[recursive?](this, ol, p);
    }

    method append(l: List<T>): List<T> {
        return List<T>::s_append_Helper(this, l);
    }

    method prepend(l: List<T>): List<T> {
        return List<T>::s_append_Helper(l, this);
    }

    //recursive? method partition<K=? where KeyType>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
    //    const plist = this.map<K>[recursive?](pf);
    //    return List<T>::s_partition<K>(this, plist);
    //}

    recursive? method sort(cmp: recursive? pred(_: T, _: T) -> Bool): List<T> {
        return List<T>::s_sort_Helper[recursive?](this, cmp);
    }

    //
    //Convert to Map<K, V> operations
    //
}
