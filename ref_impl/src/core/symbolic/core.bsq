//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive types used in the Bosque language
namespace NSCore;

//<summary>Special type which all values are instances of.</summary>
concept Any {
    method is<T>(): Bool # special_method
    method as<T>(): T # special_method

    method tryAs<T>(): T? # special_method
    method defaultAs<T>(default: T): T # special_method

    method isNone(): Bool # special_method
    method isSome(): Bool # special_method
}

//<summary>Special type for representing all non-none values.</summary>
concept Some provides Any {
    method update(): Some # special_method
    method merge(): Some # special_method
    method project<T>(): Some # special_method
    method tryProject<T>(): Some? # special_method
}

//<summary>A marker concept that indicates a type has a convert method that will allow conversion to a supertype -- used for method override contravariance</summary>
concept Convertable provides Any {
}

//<summary>Special type for indicating this type supports typed string use.</summary>
concept Parsable provides Any {
    abstract static tryParse(str: String): Result<Any, String>;
}

//<summary>Special type that all Validator (regex etc.) types provide.</summary>
concept Validator provides Any {
    abstract static accepts(str: String): Bool; 
}

//<summary>Special type for indicating a value can be used as a key in a collection.</summary>
concept KeyType provides Any {
    static equal(a: KeyType, b: KeyType): Bool # special_method
    static less(a: KeyType, b: KeyType): Bool # special_method
}

//<summary>Type for indicating that a datatype is Plain-Old-Data.</summary>
concept PODType provides APIType {
    static bufferify<T where grounded PODType>(data: T, format?: BufferFormat, encoding?: BufferEncoding, compression?: BufferCompression): Buffer<T> # pod_bufferify
    static parseBuffer<T where grounded PODType>(data: Buffer<T>): T # pod_parsebuffer
    static tryParseBuffer<T where grounded PODType>(data: Buffer<T>): Result<T, String> # pod_tryparsebuffer
}

//<summary>Type to unify Buffers and APITypes at top level for checking</summary>
concept APIValue provides Any {
}

//<summary>Type for indicating that a datatype can be exported as part of a stable API.</summary>
concept APIType provides APIValue {
    static bufferify<T where grounded APIType>(data: T, format?: BufferFormat, encoding?: BufferEncoding, compression?: BufferCompression): Buffer<T> # api_bufferify
    static parseBuffer<T where grounded APIType>(data: Buffer<T>): T # api_parsebuffer
    static tryParseBuffer<T where grounded APIType>(data: Buffer<T>): Result<T, String> # api_tryparsebuffer
}

//<summary>Type for representing the none-value.</summary>
byvalue concept Truthy provides KeyType, Parsable {
    static truth(v: Truthy): Bool {
        return !!v;
    }

    override static tryParse(str: String): Result<Truthy, String> {
        if(str == "none") {
            return Result<Truthy, String>::ok(none);
        }
        else if(str == "false") {
            return Result<Truthy, String>::ok(false);
        }
        else if(str == "true") {
            return Result<Truthy, String>::ok(true);
        }
        else {
            return Result<Truthy, String>::err("Expected Truthy");
        }
    }
}

//<summary>Type for representing the none-value.</summary>
byvalue entity None provides Truthy, PODType, APIType {
    override static tryParse(str: String): Result<None, String> {
        if(str == "none") {
            return Result<None, String>::ok(none);
        }
        else {
            return Result<None, String>::err("Expected None");
        }
    }
}

//<summary>Primitive boolean value.</summary>
byvalue entity Bool provides Some, Truthy, PODType, APIType {
    override static tryParse(str: String): Result<Bool, String> {
        if(str == "false") {
            return Result<Truthy, String>::ok(false);
        }
        else if(str == "true") {
            return Result<Truthy, String>::ok(true);
        }
        else {
            return Result<Truthy, String>::err("Expected Bool");
        }
    }

    static stringify(b: Bool): String {
        return b ? "true" : "false";
    }

    static parse(str: String): Bool {
        check str == "false" || str == "true";
        return (str == "false") ? false : true;
    }
}

//<summary>Primitive integer value.</summary>
byvalue entity Int provides KeyType, Parsable, PODType, APIType, Some {
    const min_value = -9007199254740991;
    const max_value = 9007199254740991;

    override static tryParse(str: String): Result<Int, String> # int_tryparse

    static stringify(i: Int): String # int_tostring
    static parse(str: String): Int # int_parse

    static max(v1: Int, v2: Int): Int {
        return v1 > v2 ? v1 : v2;
    }

    static min(v1: Int, v2: Int): Int {
        return v1 < v2 ? v1 : v2;
    }

    static mod(a: Int, b: Int): Int # int_mod
}

//<summary>Primitive big-integer value.</summary>
entity BigInt provides KeyType, Parsable, PODType, APIType, Some {
    override static tryParse(str: String): Result<BigInt, String> # bigint_tryparse

    static stringify(i: BigInt): String # bigint_tostring
    static parse(str: String): BigInt # bigint_parse
}

//<summary>Primitive float 64 value.</summary>
byvalue entity Float64 provides Parsable, PODType, APIType, Some {
    override static tryParse(str: String): Result<Float64, String> # float64_tryparse

    static stringify(f: Float64): String # float64_tostring
    static parse(str: String): Float64 # float64_parse
}

//<summary>Primitive string value.</summary>
entity String provides KeyType, PODType, APIType, Some {
    method length(): Int # string_count

    method charAt(idx: Int): String # string_charat
    method charCodeAt(idx: Int): Int # string_charcodeat

    static concat(...args: List<String>): String # string_concat
    method substring(start?: Int, end?: Int): String # string_substring

    method includes(str: String): Bool # string_includes
    method startsWith(str: String): Bool # string_startswith
    method endsWith(str: String): Bool # string_endswith

    method indexOf(str: String): Int # string_indexof
    method lastIndexOf(str: String): Int # string_indexof

    method split(sep: String): List<String> # string_indexof
    static join(sep: String, args: List<String>): String # string_join

    method trim(): String # string_trim
    method trimStart(): String # string_trimstart
    method trimEnd(): String # string_trimend

    static compare(a: String, b: String): Bool # string_compare
}

//<summary>Primitive safe string value.</summary>
entity SafeString<T where Validator> provides KeyType, Some, PODType, APIType, Convertable {
    method string(): String # safestring_string

    static as(str: String): SafeString<T> # safestring_as
    static tryAs(str: String): SafeString<T>? # safestring_tryas

    method convert<U where Validator>(): SafeString<U> # stringof_convert
    method tryConvert<U where Validator>(): SafeString<U>? # stringof_tryconvert
}

//<summary>Primitive stringof value.</summary>
entity StringOf<T where Parsable> provides APIValue, KeyType, Some, Convertable {
    method string(): String # stringof_string

    static as(str: String): StringOf<T> # stringof_as
    static tryAs(str: String): StringOf<T>? # stringof_tryas

    method convert<U where Parsable>(): StringOf<U> # stringof_convert
    method tryConvert<U where Parsable>(): StringOf<U>? # stringof_tryconvert
}

enum BufferFormat {
    bosque,
    json,
    binary
}

enum BufferEncoding {
    utf8,
    uri,
    base64
}

enum BufferCompression {
    off,
    rle,
    time,
    space
}

//<summary>An efficient buffer encoding for data.</summary>
entity Buffer<T where grounded PODType | APIType> provides APIValue, Some {
    method bytes(): ByteBuffer # buffer_bytes
}

//<summary>An efficient byte buffer for data.</summary>
entity ByteBuffer provides APIValue, Some {
}

//<summary>Primitive ISO standard date time value.</summary>
byvalue entity ISOTime provides Parsable, PODType, APIType, Some {
    override static tryParse(str: String): Result<ISOTime, String> # time_tryparse
}

//<summary>Primitive UUID value.</summary>
byvalue entity UUID provides KeyType, Parsable, PODType, APIType, Some {
    override static tryParse(str: String): Result<UUID, String> # uuid_tryparse
}

//<summary>All actual ordered event times implicitly provide this.</summary>
byvalue entity LogicalTime provides KeyType, Parsable, PODType, APIType, Some {
    override static tryParse(str: String): Result<LogicalTime, String> # logicaltime_tryparse

    static zero(): LogicalTime # logicaltime_zero
    static tick(t: LogicalTime): LogicalTime # logicaltime_tick
}

//<summary>Primitive hash value suitable for content addressable operations or crypto secure digests.</summary>
entity CryptoHash provides KeyType, Parsable, PODType, APIType, Some {
    static compute<T>(value: T): CryptoHash # cryptohash_compute

    override static tryParse(str: String): Result<CryptoHash, String> # cryptohash_tryparse
}

//<summary>All actual enums implicitly provide this.</summary>
concept Enum provides KeyType, Some {
}

//<summary>All actual custom keys implicitly provide this.</summary>
concept IdKey provides KeyType, Some {
}

//<summary>A concept for dealing with guid ids.</summary>
concept UUIDIdKey provides KeyType, Some {
}

//<summary>A concept for dealing with eventime ids.</summary>
concept LogicalTimeIdKey provides KeyType, Some {
}

//<summary>A concept for dealing with hashes -- is an API type if underlying type is an API type.</summary>
concept ContentHashIdKey provides KeyType, Some {
}

//<summary>Primitive regex value.</summary>
entity Regex provides Some {
    method accepts(str: String, start?: Int, end?: Int): Bool # regex_accepts
    method match(str: String, start?: Int, end?: Int): RegexMatch # regex_match
    
    method matchAll(str: String, start?: Int, end?: Int): List<RegexMatch> # regex_matchall
}

//<summary>All actual tuples implicitly provide this concept.</summary>
concept Tuple provides Some {
}

//<summary>All actual records implicitly provide this concept.</summary>
concept Record provides Some {
}

byvalue entity MapEntry<K where KeyType, V> provides Some {
    field key: K;
    field value: V;

    static create(k: K, v: V): MapEntry<K, V> {
        return MapEntry<K, V>@{ key=key, value=value };
    }
}

//<summary>Providing this concept allows for an entity to be compared or stored in a key based container using the key field.</summary>
byvalue concept Result<T, E> provides Some, Convertable {
    static ok(result: T): Result<T, E> {
        return Ok<T, E>::create(result);
    }

    static err(info: E): Result<T, E> {
        return Err<T, E>::create(info);
    }

    method isOk(): Bool {
        return this->is<Ok<T, E>>();
    }

    method isErr(): Bool {
        return this->is<Err<T, E>>();
    }

    method value(): T # result_result
    method error(): E # result_error

    method convert<U, V>(): Result<U, V> {
        return this->ok() ? Result<U, V>::ok(this.value->as<U>()) : Result<U, V>::err(this.error);
    }
}

byvalue entity Ok<T, E> provides Result<T, E> {
    field value: T;

    static of(value: T): Ok<T, E> {
        return Ok<T, E>@{ value=value };
    }
}

byvalue entity Err<T, E> provides Result<T, E> {
    field error: E;

    static of(info: E): Err<T, E> {
        return Err<T, E>@{ error=info };
    }
}

//<summary>All actual entities/concepts implicitly provide this concept.</summary>
concept Object provides Some {
}

byvalue entity RegexCapture provides Object {
    field index: Int;
    field length: Int;
    field value: String;
}

byvalue entity RegexGroup provides Object {
    field success: Bool;
    field name: String;
    field captures: List<RegexCapture>;
}

byvalue entity RegexMatch provides Object {
   field success: Bool;
   field index: Int;
   field length: Int;
   field value: String;
   field groups: List<RegexGroup>; 
}

