//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity Map<K where KeyType, V> provides Object, Expandoable<MapEntry<K, V>>, PODType when K PODType && V PODType, APIType when K APIType && V APIType {
    hidden static _size(m: Map<K, V>): Int # map_size
    hidden static _has_key(m: Map<K, V>, key: K): Bool # map_has_key
    hidden static _at_val(m: Map<K, V>, key: K): V # map_at_val

    hidden static _get_keylist(m: Map<K, V>): KeyList<K>? # map_get_keylist
    
    hidden static _unsafe_add(m: Map<K, V>, key: K, val: V, newkl: KeyList<K>): Map<K, V> # map_unsafe_add
    hidden static _unsafe_update(m: Map<K, V>, key: K, val: V): Map<K, V> # map_unsafe_update

     hidden static _add(m: Map<K, V>, k: K, v: V): Map<K, V>
        requires release !Map<K, V>::_has_key(m, k);
    {
        let kl = Map<K, V>::_get_keylist(m);
        return Map<K, V>::_unsafe_add(m, k, v, KeyList<K>@{hkey=kk, tail=kl});
    }

    hidden static _update(m: Map<K, V>, k: K, v: V): Map<K, V>
        requires release Map<K, V>::_has_key(m, k);
    {
        return Map<K, V>::_unsafe_update(m, k, v);
    }

    hidden recursive static _key_list(kl: KeyList<K>?, l: List<K>): List<K> {
        if(kl == none) {
            return l;
        }
        else {
            return Map<K, V>::_key_list[recursive](kl.tail, List<T>::_unsafe_push(l, kl.hkey));
        }
    }

    //we should be able to take keyset and has array for the set directly
    hidden static _key_set(m: Map<K, V>): Set<K> # map_keyset

    //we should be able to use the array map operation on the has has arrays
    hidden static _domainincludes(m: Map<K, V>, s: Set<K>): Bool # map_domainincludes

    hidden recursive static _value_list(m: Map<K, V>, kl: KeyList<K>?, l: List<V>): List<V> {
        if(kl == none) {
            return l;
        }
        else {
            let v = Map<K, V>::_at_val(m, kl.hkey);
            return Map<K, V>::_value_list[recursive](m, kl.tail, List<T>::_unsafe_push(l, v));
        }
    }

    hidden recursive static _entries_list(m: Map<K, V>, kl: KeyList<K>?, l: List<MapEntry<K, V>>): List<MapEntry<K, V>> {
        if(kl == none) {
            return l;
        }
        else {
            let v = Map<K, V>::_at_val(m, kl.hkey);
            return Map<K, V>::_value_list[recursive](m, kl.tail, List<T>::_unsafe_push(l, MapEntry<K, V>@{ key=kl.hkey, value=v }));
        }
    }

    hidden recursive static _hasall(m: Map<K, V>, l: List<K>, idx: Int): Bool {
        if(idx == List<K>::_size(l)) {
            return true;
        }
        else {
            let v = List<K>::_unsafe_get(l, idx);
            if(!Map<K, V>::_has_key(m, v)) {
                return false;
            }
            else {
                return Map<K, V>::_hasall[recursive](m, l, idx + 1);
            }
        }
    }

    hidden recursive static _submap(m: Map<K, V>, kl: KeyList<K>?, mp: Map<K, V>, p: recursive? fn(_: K, _: V) -> Bool): Map<K, V> {
        if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            let v = Map<K, V>::_at_val(m, k);

            if(!p[recursive?](k, v)) {
                return Map<K, V>::_submap(kl.tail, mp, p);
            }
            else {
                return Map<K, V>::_submap(kl.tail, Map<K, V>::_add(mp, k, v), p);
            }
        }
    }

    hidden recursive static _ofType<T where KeyType, U>(kl: KeyList<K>?, mp: Map<T, U>): Map<T, U> {
        if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            let v = Map<K, V>::_at_val(m, k);

            if(k->is<T>() && v->is<U>()) {
                return Map<K, V>::_ofType(kl.tail, Map<T, U>::_add(mp, k->as<T>(), v->as<U>()));
            }
            else {
                return Map<K, V>::_ofType(kl.tail, mp, p);
            }
        }
    }

    hidden recursive static _cast<T where KeyType, U>(kl: KeyList<K>?, mp: Map<T, U>): Map<T, U> {
       if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            let v = Map<K, V>::_at_val(m, k);
            check (k->is<T>() && v->is<U>());

            return Map<K, V>::_ofType(kl.tail, Map<T, U>::_add(mp, k->as<T>(), v->as<U>()));
        }
    }

    //lets steal the keylist and has array from s and pop them into the new map (some junk remains in the key/val arrays but we never look at it)
    hidden static _project(m: Map<K, V>, s: Set<K>, missingok: Bool): Map<K, V> # map_project

    hidden recursive static _exclude(m: Map<K, V>, s: Set<K>, kl: KeyList<K>?, mp: Map<K, V>): Map<K, V> {
        if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            
            if(Set<K>::_has(k)) {
                return Map<K, V>::_exclude(m, s, kl.tail, mp);
            }
            else {
                let v = Map<K, V>::_at_val(m, k);
                return Map<K, V>::_exclude(m, s, kl.tail, Map<K, V>::_add(mp, k, v));
            }
        }
    }

    hidden recursive static _remap<U>(m: Map<K, V>, kl: KeyList<K>?, mp: Map<K, U>, f: recursive? fn(_: K, _: V) -> U): Map<K, U> {
        if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            let v = Map<K, V>::_at_val(m, k);

            let u = f[recursive?](k, v);
             return Map<K, V>::_remap(kl.tail, Map<K, V>::_add(mp, k, u), f);
        }
    }

    hidden static _projectall(m: Map<K, V>, l: List<K>): Map<K, V> {
        return Map<K, V>::_project(m, List<K>::_toset[recursive](l, 0, Set<K>@{}));
    }

    hidden static _excludeall(m: Map<K, V>, l: List<K>, kl: KeyList<K>?, mp: Map<K, V>): Map<K, V> {
        return Map<K, V>::_exclude[recursive](m, List<K>::_toset[recursive](l, 0, Set<K>@{}), kl, mp);
    }

    hidden recursive static _union(m: Map<K, V>, mp: Map<K, V>, kl: KeyList<K>?): Map<K, V> {
        if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            let v = Map<K, V>::_at_val(m, k);

            return Map<K, V>::_union[recursive](m, Map<K, v>::_add(mp, k, v), kl.tail);
        }
    }

    hidden recursive static _merge(m: Map<K, V>, mp: Map<K, V>, kl: KeyList<K>?): Map<K, V> {
        if(kl == none) {
            return mp;
        }
        else {
            let k = kl.hkey;
            let v = Map<K, V>::_at_val(m, k);

            if(!Map<K, V>::_has_key(mp, kl.hkey)) {
                return Map<K, V>::_merge[recursive](m, Map<K, v>::_add(mp, k, v), kl.tail);
            }
            else {
                return Map<K, V>::_merge[recursive](m, Map<K, v>::_update(mp, k, v), kl.tail);
            }
        }
    }

    hidden recursive static _unionall(ml: List<Map<K, V>>, mp: Map<K, V>, idx: Int): Map<K, V> {
        if(idx == List<T>::_size(ml)) {
            return mp;
        }
        else {
            let m = List<T>::_unsafe_get(ml, idx);
            return Map<K, V>::_unionall[recursive](ml, mp->union(m), idx + 1);
        }
    }

    hidden recursive static _mergeall(ml: List<Map<K, V>>, mp: Map<K, V>, idx: Int): Map<K, V> {
        if(idx == List<T>::_size(ml)) {
            return mp;
        }
        else {
            let m = List<T>::_unsafe_get(ml, idx);
            return Map<K, V>::_mergeall[recursive](ml, mp->merge(m), idx + 1);
        }
    }

    override method size(): Int {
        return Map<K, V>::_size(this);
    }

    override method empty(): Bool {
        return Map<K, V>::_size(this) == 0;
    }

    override method keys(): List<K> {
        return Map<K, V>::_key_list(KeyList<K>::sort(Map<K, V>::_get_keylist(this)), List<K>@{});
    }

    override method keySet(): Set<K> {
        return Map<K, V>::_key_set(this);
    }

    override method values(): List<K> {
        return Map<K, V>::_value_list(this, KeyList<K>::sort(Map<K, V>::_get_keylist(this)), List<V>@{});
    }

    override method entries(): List<MapEntry<K, V>> {
        return Map<K, V>::_entry_list(this, KeyList<K>::sort(Map<K, V>::_get_keylist(this)), List<MapEntry<K, V>>@{});
    }

    method toDynamicMap(): DynamicMap<K, V> {
        abort;
    }

    override method has(key: K): Bool {
        return Map<K, V>::_has_key(this, k)
    }

    override method hasAll(...kl: List<K>): Bool {
        return Map<K, V>::_hasall[recursive](this, kl, 0);
    }

    override method domainIncludes(s: Set<K>): Bool {
        if(Set<K>::_size(s) > Map<K, V>::_size(this)) {
            return false;
        }
        else {
            return Map<K, V>::_domainincludes(this, s);
        }
    }

    override method get(key: K): V 
        requires release Map<K, V>::_has_key(this, k);
    {
        return Map<K, V>::_at_val(this, k);
    }

    override method tryGet(k: K): V? {
        return Map<K, V>::_has_key(this, k) ? Map<K, V>::_at_val(this, k) : none;
    }

    recursive? method submap(p: recursive? fn(_: K, _: V) -> Bool): Map<K, V> {
        return Map<K, V>::_submap[recursive](this, Map<K, V>::_get_keylist(this), Map<K, V>@{}, p);
    }

    method ofType<T where KeyType, U>(): Map<T, U> {
        return Map<K, V>::_oftype<T, U>[recursive](Map<K, V>::_get_keylist(this), Map<T, U>@{});
    }

    method cast<T where KeyType, U>(): Map<T, U> {
        return Map<K, V>::_cast<T, U>[recursive](Map<K, V>::_get_keylist(this), Map<T, U>@{});
    }

    method project(ds: Set<K>, missingok?: Bool): Map<K, V> {
        return Map<K, V>::_project(this, ds, Truthy::truth(missingok));
    }

    method exclude(ds: Set<K>): Map<K, V> {
        return Map<K, V>::_exclude[recursive](this, ds, Map<K, V>::_get_keylist(this), Map<K, V>@{});
    }

    recursive? method remap<U>(f: recursive? fn(_: K, _: V) -> U): Map<K, U> {
        return Map<K, V>::_remap<U>[recursive](this, Map<K, V>::_get_keylist(this)->reverse(), Map<K, U>@{}, f);
    }

    method projectAll(...kl: List<K>): Map<K, V> {
        return Map<K, V>::_projectall(this, kl);
    }

    method excludeAll(...kl: List<K>): Map<K, V> {
        return Map<K, V>::_excludeall(this, kl, Map<K, V>::_get_keylist(this), Map<K, V>@{});
    }

    method union(m: Map<K, V>): Map<K, V> {
        return Map<K, V>::_union[recursive](s, this, Map<K, V>::_get_keylist(s));
    }

    static unionOf(...ml: List<Map<K, V>>): Map<K, V> {
        if(List<T>::_size(ml) == 0) {
            return Map<K, V>@{};
        }
        else if(List<T>::_size(ml) == 1) {
            return List<T>::_unsafe_get(ml, 0);
        }
        else {
            return Set<T>::_unionall(ml, Map<K, V>@{}, 0);
        }
    }

    method merge(m: Map<K, V>): Map<K, V> {
        return Map<K, V>::_merge[recursive](s, this, Map<K, V>::_get_keylist(s));
    }

    static mergeOf(...ml: List<Map<K, V>>): Map<K, V> {
        if(List<T>::_size(ml) == 0) {
            return Map<K, V>@{};
        }
        else if(List<T>::_size(ml) == 1) {
            return List<T>::_unsafe_get(ml, 0);
        }
        else {
            return Set<T>::_mergeall(ml, Map<K, V>@{}, 0);
        }
    }
}

entity DynamicMap<K where KeyType, V> provides Object, Expandoable<MapEntry<K, V>> {
    override method size(): Int {
        abort;
    }

    override method empty(): Bool  {
        abort;
    }

    override method keys(): List<K>  {
        abort;
    }

    override method keySet(): Set<K>  {
        abort;
    }

    override method values(): List<K>  {
        abort;
    }

    override method entries(): List<MapEntry<K, V>>  {
        abort;
    }

    method toMap(): DynamicMap<K, V> {
        abort;
    }

    override method has(key: K): Bool {
        abort;
    }

    override method hasAll(...ks: List<K>): Bool {
        abort;
    }

    override method domainIncludes(s: Set<K>): Bool {
        abort;
    }

    override method get(key: K): V {
        abort;
    }

    override method tryGet(k: K): V? {
        abort;
    }

    method add(k: K, v: V): DynamicMap<K, V> {
        abort;
    }

    method addAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method insert(k: K, v: V): DynamicMap<K, V> {
        abort;
    }

    method insertAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method update(k: K, v: V): DynamicMap<K, V> {
        abort;
    }

    method updateAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method remove(k: K): DynamicMap<K, V> {
        abort;
    }

    method removeAll(...kl: List<K>): DynamicMap<K, V> {
        abort;
    }

    recursive? method submap(p: recursive? fn(_: K, _: V) -> Bool): DynamicMap<K, V> {
        abort;
    }

    method ofType<T where KeyType, U>(): Map<T, U> {
        abort;
    }

    method cast<T where KeyType, U>(): Map<T, U> {
        abort;
    }

    method project(ds: Set<K>, missingok?: Bool): Map<K, V> {
        abort;
    }

    method exclude(ds: Set<K>): Map<K, V> {
        abort;
    }

    recursive? method remap<U>(f: recursive? fn(_: K, _: V) -> U): DynamicMap<K, U> {
        abort;
    }

    method projectAll(...kl: List<K>): DynamicMap<K, V> {
        abort;
    }

    method excludeAll(...kl: List<K>): Map<K, V> {
        abort;
    }

    method unionWith(m: Map<K, V>): DynamicMap<K, V> {
        abort;
    }

    static union(...ml: List<Map<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method mergeWith(m: Map<K, V>): DynamicMap<K, V> {
        abort;
    }

    static merge(...ml: List<Map<K, V>>): DynamicMap<K, V> {
        abort;
    }
}


