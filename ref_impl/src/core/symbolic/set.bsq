//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity AbstractSet<T where KeyType> provides Object {
    abstract method size(): Int;
    abstract method empty(): Bool;
    abstract method entries(): List<T>;

    abstract method has(v: T): Bool;
    abstract method hasAll(...v: List<T>): Bool;
}

entity Set<T where KeyType> provides AbstractSet<T>, PODType when T grounded PODType, APIType when T grounded APIType {
    hidden static _size(s: Set<T>): Int # set_size
    hidden static _has_key(s: Set<T>, key: T): Bool # set_has_key
    hidden static _get_keylist(s: Set<T>): KeyList<T>? # set_get_keylist
    hidden static _unsafe_add(s: Set<T>, v: T, newkl: KeyList<T>): Set<T> # set_unsafe_add

    hidden static _add(s: Set<T>, v: T): Set<T> {
        if(Set<T>::_has_key(s, v)) {
            return s;
        }
        else {
            let kl = Set<T>::_get_keylist(s);
            return Set<T>::_unsafe_add(s, v, KeyList<T>@{hkey=k, tail=kl});
        }
    }

    //we should be able to use the array map operation on the has array
    hidden static _subsetof(s: Set<T>, other: Set<T>): Bool # set_subsetof
    hidden static _equal(s: Set<T>, other: Set<T>): Bool # set_equal
    hidden static _disjoint(s: Set<T>, other: Set<T>): Bool # set_disjoint

    hidden recursive static _entry_list(kl: KeyList<T>?, l: List<T>): List<T> {
        if(kl == none) {
            return l;
        }
        else {
            return Set<T>::_entry_list[recursive](kl.tail, List<T>::_unsafe_push(l, kl.hkey));
        }
    }

    hidden recursive static _hasall(s: Set<T>, l: List<T>, idx: Int): Bool {
        if(idx == List<T>::_size(l)) {
            return true;
        }
        else {
            let v = List<T>::_unsafe_get(l, idx);
            if(!Set<T>::_has_key(s, v)) {
                return false;
            }
            else {
                return Set<T>::_hasall[recursive](s, l, idx + 1);
            }
        }
    }

    hidden recursive static _subset(kl: KeyList<T>?, sp: Set<T>, p: recursive? fn(_: T) -> Bool): Set<T> {
        if(kl == none) {
            return sp;
        }
        else {
            if(p[recursive?](kl.hkey)) {
                return Set<T>::_subset[recursive](Set<T>::_add(sp, kl.hkey), kl.tail, p);
            }
            else {
                return Set<T>::_subset[recursive](sp, kl.tail, p);
            }
        }
    }

    hidden recursive static _oftype<U where KeyType>(kl: KeyList<T>?, sp: Set<U>): Set<U> {
        if(kl == none) {
            return sp;
        }
        else {
            if(kl.hkey->is<U>()) {
                return Set<T>::_oftype[recursive](Set<U>::_add(sp, kl.hkey->as<U>()), kl.tail);
            }
            else {
                return Set<T>::_oftype[recursive](sp, kl.tail, p);
            }
        }
    }

    hidden recursive static _cast<U where KeyType>(kl: KeyList<T>?, sp: Set<U>): Set<U> {
        if(kl == none) {
            return sp;
        }
        else {
            return Set<T>::_cast[recursive](Set<U>::_add(sp, kl.hkey->as<U>()), kl.tail);
        }
    }

    hidden recursive static _union(sp: Set<T>, kl: KeyList<T>?): Set<T> {
        if(kl == none) {
            return sp;
        }
        else {
            return Set<T>::_union[recursive](Set<T>::_add(sp, kl.hkey), kl.tail);
        }
    }

    hidden recursive static _intersect(s: Set<T>, sp: Set<T>, kl: KeyList<T>?): Set<T> {
        if(kl == none) {
            return sp;
        }
        else {
            if(!Set<T>::_has_key(s, kl.hkey)) {
                return Set<T>::_intersect(s, sp, kl.tail);
            }
            else {
                return Set<T>::_intersect[recursive](s, Set<T>::_add(sp, kl.hkey), kl.tail);
            }
        }
    }

    hidden recursive static _diff(os: Set<T>, sp: Set<T>, kl: KeyList<T>?): Set<T> {
        if(kl == none) {
            return sp;
        }
        else {
            if(Set<T>::_has_key(os, kl.hkey)) {
                return Set<T>::_diff[recursive](os, sp, kl.tail);
            }
            else {
                return Set<T>::_diff[recursive](os, Set<T>::_add(sp, kl.hkey), kl.tail);
            }
        }
    }

    hidden recursive static _unionall(sl: List<Set<T>>, sp: Set<T>, idx: Int): Set<T> {
        if(idx == List<T>::_size(sl)) {
            return sp;
        }
        else {
            let s = List<T>::_unsafe_get(sl, idx);
            return Set<T>::_unionall[recursive](sl, sp->union(s), idx + 1);
        }
    }

    hidden recursive static _intersectall(sl: List<Set<T>>, sp: Set<T>, idx: Int): Set<T> {
        if(idx == List<T>::_size(sl)) {
            return sp;
        }
        else {
            let s = List<T>::_unsafe_get(sl, idx);
            return Set<T>::_intersectall[recursive](sl, sp->intersect(s), idx + 1);
        }
    }

    override method size(): Int {
        return Set<T>::_size(this);
    }

    override method empty(): Bool {
        return Set<T>::_size(this) == 0;
    }

    override method entries(): List<T> {
        return Set<T>::_entry_list(KeyList<K>::sort(Set<T>::_get_keylist(this)), List<T>@{});
    }

    override method has(v: T): Bool {
        return Set<T>::_has_key(this, v);
    }

    override method hasAll(...v: List<T>): Bool {
        return Set<T>::_hasall[recursive](this, v, 0);
    }

    method toDynamicSet<T>(): DynamicSet<T> {
        abort;
    }

    method subsetOf(s: Set<T>): Bool {
        if(Set<T>::_size(s) > Set<T>::_size(this)) {
            return false;
        }
        else {
            return Set<T>::_subsetof(this, s);
        }
    }

    method equal(s: Set<T>): Bool {
        if(Set<T>::_size(this) != Set<T>::_size(s)) {
            return false;
        }
        else {
            return Set<T>::_equal(this, s);
        }
    }

    method disjoint(s: Set<T>): Bool {
        return Set<T>::_disjoint(this, s);
    }

    recursive? method subset(p: recursive? fn(_: T) -> Bool): Set<T> {
        return Set<T>::_subset[recursive](Set<T>::_get_keylist(this), Set<T>@{}, p);
    }

    method ofType<U where KeyType>(): Set<U> {
        return Set<T>::_oftype<U>[recursive](Set<T>::_get_keylist(this), Set<U>@{}, 0);
    }

    method cast<U where KeyType>(): Set<U> {
        return Set<T>::_cast<U>[recursive](Set<T>::_get_keylist(this), Set<U>@{}, 0);
    }

    method union(s: Set<T>): Set<T> {
        return Set<T>::_union[recursive](this, Set<T>::_get_keylist(s));
    }

    method intersect(s: Set<T>): Set<T> {
        return Set<T>::_intersect[recursive](s, Set<T>@{}, Set<T>::_get_keylist(this));
    }

    method difference(s: Set<T>): Set<T> {
        return Set<T>::_diff[recursive](s, Set<T>@{}, Set<T>::_get_keylist(this));
    }

    method symmetricDifference(s: Set<T>): Set<T> {
        let d1 = this->diffWith(s);
        let d2 = s->diffWith(this);
        return d1->unionWith(d2);
    }

    static unionOf(...sl: List<Set<T>>): Set<T> {
        if(List<T>::_size(sl) == 0) {
            return Set<T>@{};
        }
        else if(List<T>::_size(sl) == 1) {
            return List<T>::_unsafe_get(sl, 0);
        }
        else {
            return Set<T>::_unionall(sl, Set<T>@{}, 0);
        }
    }

    static intersectionOf(...sl: List<Set<T>>): Set<T> {
        if(List<T>::_size(sl) == 0) {
            return Set<T>@{};
        }
        else if(List<T>::_size(sl) == 1) {
            return List<T>::_unsafe_get(sl, 0);
        }
        else {
            return Set<T>::_intersectall(sl, Set<T>@{}, 0);
        }
    }
}

entity DynamicSet<T where KeyType> provides AbstractSet<T> {
    override method size(): Int {
        abort;
    }

    override method empty(): Bool {
        abort;
    }

    override method entries(): List<T> {
        abort;
    }

    override method has(v: T): Bool  {
        abort;
    }

    override method hasAll(...v: List<T>): Bool  {
        abort;
    }

    method toSet<T>(): Set<T> {
        abort;
    }

    method add(v: T): DynamicSet<T>  {
        abort;
    }

    method addAll(...v: List<T>): DynamicSet<T>  {
        abort;
    }

    method insert(v: T): DynamicSet<T>  {
        abort;
    }

    method insertAll(...v: List<T>): DynamicSet<T>  {
        abort;
    }

    method remove(v: T): DynamicSet<T>  {
        abort;
    }

    method removeAll(...v: List<T>): DynamicSet<T>  {
        abort;
    }

    method subsetOf(s: DynamicSet<T>): Bool  {
        abort;
    }

    method equal(s: DynamicSet<T>): Bool  {
        abort;
    }

    method disjoint(s: DynamicSet<T>): Bool  {
        abort;
    }

    recursive? method subset(p: recursive? fn(_: T) -> Bool): Set<T> {
        abort;
    }

    method ofType<U where KeyType>(): Set<U> {
        abort;
    }

    method cast<U where KeyType>(): Set<U> {
        abort;
    }

    method union(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    method intersect(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    method difference(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    method symmetricDifference(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    static unionOf(...sl: List<DynamicSet<T>>): DynamicSet<T> {
        abort;
    }

    static intersectionOf(...sl: List<DynamicSet<T>>): DynamicSet<T> {
        abort;
    }
}
