//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the fluent core language
namespace NSCore;

//<summary>A List entity.</summary>
//
//TODO: this is where we want to use POD when T POD
//
entity List<T> provides Object {
    hidden static _size(l: List<T>): Int # _listsize
    hidden static _unsafe_at(l: List<T>, i: Int): T # _listunsafe_at
    hidden static _unsafe_set(l: List<T>, i: Int, v: T): List<T> # _listunsafe_set
    hidden static _destructive_add(l: List<T>, v: T): List<T> # _listdestructive_add

    hidden recursive static _filter(l: List<T>, idx: Int, lp: List<T>, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }

        var val = List<T>::_unsafe_at(l, idx);
        if(p[recursive?](val)) {
            return List<T>::_filter[recursive](l, idx + 1, List<T>::_destructive_add(lp, val), p);
        }
        else {
            return List<T>::_filter[recursive](l, idx + 1, lp, p);
        }
    }

    hidden recursive static _map<U>(l: List<T>, idx: Int, lp: List<U>, f: recursive? fn(_: T) -> U): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }

        var val = f[recursive?](List<T>::_unsafe_at(l, idx));
        return List<T>::_map<U>[recursive](l, idx + 1, List<T>::_destructive_add(lp, val), p);
    }

    method size(): Int {
        return List<T>::_size(this);
    }
    
    method empty(): Bool {
        return List<T>::_size(this) == 0;
    }

    method at(idx: Int): T {
        check 0 <= idx && idx < List<T>::_size(this);

        return List<T>::_unsafe_at(this, idx);
    }

    method set(idx: Int, v: T): List<T> {
        check 0 <= idx && idx < List<T>::_size(this);

        return List<T>::_unsafe_set(this, idx, v);
    }

    method filter(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<U>::_filter(this, 0, List<T>{}, p);
    }

    method map<U>(f: recursive? fn(_: T) -> U): List<U> {
        return List<U>::_map(this, 0, List<U>{}, f);
    }
}

//<summary>A Set entity.</summary>
//
//TODO: this is where we want to use POD when T POD
//TODO: want to add type gen macro T % KeyType that expands to the type of getKey(v) -- also should update the sig of Indexable::getKey
//
entity Set<T where Indexable> provides Object {
    hidden static _size(s: Set<T>): Int # _setsize
    hidden static _unsafe_at_key(s: Set<T>, i: Int): KeyType # _setunsafe_at_key
    hidden static _unsafe_at_val(s: Set<T>, i: Int): T # _setunsafe_at_val
    hidden static _unsafe_set(s: Set<T>, i: Int, k: KeyType, v: T): Set<T> # _setunsafe_set
    hidden static _destructive_set(s: Set<T>, i: Int, k: KeyType, v: T): Set<T> # _setdestuctive_set
    hidden static _unsafe_add(s: Set<T>, k: KeyType, v: T): Set<T> # _setunsafe_add
    hidden static _destructive_add(s: Set<T>, k: KeyType, v: T): Set<T> # _setdestuctive_add

    hidden recursive static _unsafe_remove(s: Set<T>, sp: Set<T>, i: Int, pos: Int): Set<T> {
        if(pos == Set<T>::_size(s)) {
            return sp;
        }

        if(pos == i) {
            return Set<T>::_unsafe_remove[recursive](s, sp, i, pos + 1);
        }
        else {
            var key = Set<T>::_unsafe_at_key(s, pos);
            var val = Set<T>::_unsafe_at_val(s, pos);
            return Set<T>::_unsafe_remove[recursive](s, Set<T>::_destructive_add(sp, key, val), i, pos + 1);
        }
    }

    hidden recursive static _find(s: Set<T>, idx: Int, k: KeyType): Int {
        if(idx == Set<T>::_size(s)) {
            return Set<T>::_size(s);
        }

        var key = Set<T>::_unsafe_at_key(s, idx);
        if(Indexable::equal(k, key)) {
            return idx;
        }
        else {
            return Set<T>::_find[recursive](s, idx + 1, k);
        }
    }

    hidden static cons_insert(s: Set<T>, v: T): Set<T> {
        var key = Indexable::getKey(v);
        if(Set<T>::_size(s) == 0) {
            return Set<T>::_destructive_add(s, key, v);
        }
        else {
            var loc = Set<T>::_find[recursive](s, 0, key);
            return Set<T>::_destructive_set(s, loc, key, v);
        }
    }

    method size(): Int {
        return Set<T>::_size(this);
    }
    
    method empty(): Bool {
        return Set<T>::_size(this) == 0;
    }
    
    method has(v: T): Bool {
        return Set<T>::_find[recursive](this, 0, Indexable::getKey(v)) != Set<T>::_size(this);
    }

    method insert(v: T): Set<T> {
        var key = Indexable::getKey(v);
        var loc = Set<T>::_find[recursive](this, 0, key);
        if(loc == Set<T>::_size(this)) {
            return Set<T>::_unsafe_add(this, key, v);
        }
        else {
            return Set<T>::_unsafe_set(this, loc, key, v);
        }
    }

    method remove(v: T): Set<T> {
        var loc = Set<T>::_find[recursive](this, 0, Indexable::getKey(v));
        if(loc == Set<T>::_size(this)) {
            return this;
        }
        else {
            return Set<T>::_unsafe_remove[recursive](this, Set<T>{}, loc, 0);
        }
    }
}

//<summary>A Map entity.</summary>
//
//TODO: this is where we want to use POD when T POD
//
entity Map<K where Indexable, V> provides Object {
    hidden static _size(m: Map<K, V>): Int # _mapsize
    hidden static _unsafe_at_key(m: Map<K, V>, i: Int): KeyType # _mapunsafe_at_key
    hidden static _unsafe_at_val(m: Map<K, V>, i: Int): [K, V] # _mapunsafe_at_val
    hidden static _unsafe_set(m: Map<K, V>, i: Int, k: KeyType, v: [K, V]): Map<K, V> # _mapunsafe_set
    hidden static _destructive_set(m: Map<K, V>, i: Int, k: KeyType, v: [K, V]): Map<K, V> # _mapdestuctive_set
    hidden static _unsafe_add(m: Map<K, V>, k: KeyType, v: [K, V]): Map<K, V> # _mapunsafe_add
    hidden static _destructive_add(m: Map<K, V>, k: KeyType, v: [K, V]): Map<K, V> # _mapdestuctive_add

    hidden recursive static _unsafe_remove(m: Map<K, V>, mp: Map<K, V>, i: Int, pos: Int): Map<K, V> {
        if(pos == Set<T>::_size(m)) {
            return mp;
        }

        if(pos == i) {
            return Map<K, V>::_unsafe_remove[recursive](m, mp, i, pos + 1);
        }
        else {
            var key = Map<K, V>::_unsafe_at_key(m, pos);
            var val = Map<K, V>::_unsafe_at_val(m, pos);
            return Map<K, V>::_unsafe_remove[recursive](m, Map<K, V>::_destructive_add(mp, key, val), i, pos + 1);
        }
    }

    hidden recursive static _find(m: Map<K, V>, idx: Int, k: KeyType): Int {
        if(idx == Map<K, V>::_size(m)) {
            return Map<K, V>::_size(m);
        }

        var key = Map<K, V>::_unsafe_at_key(m, idx);
        if(Indexable::equal(k, key)) {
            return idx;
        }
        else {
            return Map<K, V>::_find[recursive](m, idx + 1, k);
        }
    }

    hidden static cons_insert(m: Map<K, V>, v: [K, V]): Map<K, V> {
        var key = Indexable::getKey(v.0);
        if(Map<K, V>::_size(m) == 0) {
            return Map<K, V>::_destructive_add(m, key, v);
        }
        else {
            var loc = Map<K, V>::_find[recursive](m, 0, key);
            return Map<K, V>::_destructive_set(m, loc, key, v);
        }
    }

    method size(): Int {
        return Map<K, V>::_size(this);
    }
    
    method empty(): Bool {
        return Map<K, V>::_size(this) == 0;
    }
    
    method has(key: K): Bool {
        return Map<K, V>::_find[recursive](this, 0, Indexable::getKey(key)) != Map<K, V>::_size(this);
    }

    method get(key: K): V {
        var loc = Map<K, V>::_find[recursive](this, 0, Indexable::getKey(key));
        check loc != Map<K, V>::_size(this);

        return Map<K,V>::_unsafe_at_val(this, loc).1;
    }

    method tryGet(key: K): V? {
        var loc = Map<K, V>::_find[recursive](this, 0, Indexable::getKey(key));
        
        return loc != Map<K, V>::_size(this) ? Map<K,V>::_unsafe_at_val(this, loc.pos) : none;
    }

    method set(key: K, val: V): Map<K, V> {
        var k = Indexable::getKey(v.0);
        if(Map<K, V>::_size(m) == 0) {
            return Map<K, V>::_unsafe_add(m, k, [key, v]);
        }
        else {
            var loc = Map<K, V>::_find[recursive](m, 0, k);
            return Map<K, V>::_unsafe_set(m, loc, k, [key, v]);
        }
    }

    method remove(key: K): Map<K, V> {
        var loc = Map<K, V>::_find[recursive](this, 0, Indexable::getKey(key));
        if(loc == Map<K, V>::_size(this)) {
            return this;
        }
        else {
            return Map<K, V>::_unsafe_remove[recursive](this, Map<K, V>{}, loc, 0);
        }
    }
}
