//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the fluent core language
namespace NSCore;

//<summary>Type for representing all non-none values.</summary>
concept Collection<T> provides Object {
}

entity ListEntry<T> provides Object {
    field entry: T;
    field tail: ListEntry<T>?;

     recursive method at(idx: Int): T {
        if(idx == 0) {
            return this.entry;
        }
        else {
            var tl = this.tail;
            check tl != none;

            return tl->at[recursive](idx - 1);
        }
    }

    recursive method map<U>(f: recursive? fn(_: T) -> U): ListEntry<U> {
        var nentry = f[recursive?](this.entry);

        var tl = this.tail;
        if(tl == none) {
            return ListEntry<U>{entry=nentry, tail=none};
        }
        else {
            var ntail = tl->map<U>[recursive](f);
            return ListEntry<U>{entry=nentry, tail=ntail};
        }
    }
}

//<summary>A List entity.</summary>
entity List<T> provides Collection<T> {
    field size: Int;
    field list: ListEntry<T>?;

    hidden static _cons(size: Int, list: ListEntry<T>?): List<T> # _listcons

    const empty: List<T> = List<T>::_cons<T>(0, none);

    method size(): Int {
        return this.size;
    }
    
    method at(idx: Int): T {
        var tl = this.list;
        check idx < this.size && tl != none;

        return tl->at[recursive](idx);
    }

    method map<U>(f: recursive? fn(_: T) -> U): List<U> {
        var tl = this.list;
        if(tl == none) {
            return List<U>::empty;
        }
        else {
            return List<U>::_cons(this.size, tl->map<U>[recursive](f));
        }
    }
}

entity SetEntry<T where Indexable> provides Object {
    field value: T;
    field tail: SetEntry<T>?;

    recursive method has(v: T): Bool {
        if(this.value == v) {
            return true;
        }
        else {
            var tl = this.tail;
            return tl != none && tl->has[recursive](v);
        }
    }

    recursive method insert(v: T): SetEntry<T> {
        if(v == this.value) {
            return SetEntry<T>{value=v, tail=this.tail}; //replace old value
        }
        elif(v > this.value || this.tail == none) {
            return SetEntry<T>{value=v, tail=this};
        }
        else {
            var tl = this.tail;
            check tl != none;

            var newtail = tl->insert[recursive](v);
            return SetEntry<T>{value=this.value, tail=newtail};
        }
    }

    recursive method remove(v: T): SetEntry<T>? {
        if(v == this.value) {
            return this.tail; 
        }
        elif(v > this.value || this.tail == none) {
            return this;
        }
        else {
            var tl = this.tail;
            check tl != none;

            var newtail = tl->remove[recursive](v);
            return SetEntry<T>{value=this.value, tail=newtail};
        }
    }
}

//<summary>A Set entity.</summary>
entity Set<T where Indexable> provides Collection<T> {
    field size: Int;
    field set: SetEntry<T>?;

    hidden static _cons(size: Int, set: SetEntry<T>?): Set<T> # _setcons

    const empty: Set<T> = Set<T>::_cons<T>(0, none);

    method size(): Int {
        return this.size;
    }
    
    method has(v: T): Bool {
        var ts = this.set;
        return ts != none && ts->has[recursive](v); 
    }

    method insert(v: T): Set<T> {
        var ts = this.set;
        if(ts == none) {
            return Set<T>::_cons<T>(1, SetEntry<T>{value=v, tail=none});
        }
        else {
            return Set<T>::_cons<T>(this.size + (!ts->has[recursive](v) ? 1 : 0), ts->insert[recursive](v));
        }
    }

    method remove(v: T): Set<T> {
        var ts = this.set;
        if(ts == none || !this->has(v)) {
            return this;
        }
        else {
            return Set<T>::_cons<T>(this.size - 1, ts->remove[recursive](v));
        }
    }
}

entity MapEntry<K where Indexable, V> provides Object {
    field key: K;
    field value: V;
    field tail: MapEntry<K, V>?;

    recursive method has(k: K): Bool {
        if(this.key == k) {
            return true;
        }
        else {
            var tl = this.tail;
            return tl != none && tl->has[recursive](k);
        }
    }

    recursive method insert(k: K, v: V): MapEntry<K, V> {
        if(k == this.key) {
            return MapEntry<K, V>{key=k, value=v, tail=this.tail}; //replace old value
        }
        elif(k > this.key || this.tail == none) {
            return MapEntry<K, V>{key=k, value=v, tail=this};
        }
        else {
            var tl = this.tail;
            check tl != none;
            
            var newtail = tl->insert[recursive](k, v);
            return MapEntry<K, V>{key=this.key, value=this.value, tail=newtail};
        }
    }

    recursive method remove(k: K): MapEntry<K, V>? {
        if(k == this.key) {
            return this.tail; 
        }
        elif(k > this.key || this.tail == none) {
            return this;
        }
        else {
            var tl = this.tail;
            check tl != none;

            var newtail = tl->remove[recursive](k);
            return MapEntry<K, V>{key=this.key, value=this.value, tail=newtail};
        }
    }
}

//<summary>A Map entity.</summary>
entity Map<K where Indexable, V> provides Object {
    field size: Int;
    field map: MapEntry<K, V>?;

    hidden static _cons(size: Int, map: MapEntry<K, V>?): Map<K, V> # _mapcons

    const empty: Map<K, V> = Map<K, V>::_cons<K, V>(0, none);

    method size(): Int {
        return this.size;
    }
    
    method has(k: K): Bool {
        var tm = this.map;
        return tm != none && tm->has[recursive](k); 
    }

    method insert(k: K, v: V): Map<K, V> {
        var tm = this.map;
        if(tm == none) {
            return Map<K, V>::_cons<K, V>(1, MapEntry<K, V>{key=k, value=v, tail=none});
        }
        else {
            return Map<K, V>::_cons<K, V>(this.size + (!tm->has[recursive](k) ? 1 : 0), tm->insert[recursive](k, v));
        }
    }

    method remove(k: K): Map<K, V> {
        var tm = this.map;
        if(tm == none || !this->has(k)) {
            return this;
        }
        else {
            return Map<K, V>::_cons<K, V>(this.size - 1, tm->remove[recursive](k));
        }
    }
}