//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the fluent core language
namespace NSCore;

//<summary>A List entity.</summary>
//
//TODO: this is where we want to use POD when T POD
//
entity List<T> provides Object {
    hidden static _size(l: List<T>): Int # _listsize
    hidden static _unsafe_at(l: List<T>, i: Int): T # _listunsafe_at
    hidden static _unsafe_set(l: List<T>, i: Int, v: T): List<T> # _listunsafe_set
    hidden static _destructive_add(l: List<T>, v: T): List<T> # _listdestructive_add

    hidden recursive static _filter(l: List<T>, idx: Int, lp: List<T>, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }

        var val = List<T>::_unsafe_at(l, idx);
        if(p[recursive?](val)) {
            return List<T>::_filter[recursive](l, idx + 1, List<T>::_destructive_add(lp, val), p);
        }
        else {
            return List<T>::_filter[recursive](l, idx + 1, lp, p);
        }
    }

    hidden recursive static _map<U>(l: List<T>, idx: Int, lp: List<U>, f: recursive? fn(_: T) -> U): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }

        var val = f[recursive?](List<T>::_unsafe_at(l, idx));
        return List<T>::_map<U>[recursive](l, idx + 1, List<T>::_destructive_add(lp, val), p);
    }

    method size(): Int {
        return List<T>::_size(this);
    }
    
    method empty(): Bool {
        return List<T>::_size(this) == 0;
    }

    method at(idx: Int): T {
        check 0 <= idx && idx < List<T>::_size(this);

        return List<T>::_unsafe_at(this, idx);
    }

    method set(idx: Int, v: T): List<T> {
        check 0 <= idx && idx < List<T>::_size(this);

        return List<T>::_unsafe_set(this, idx, v);
    }

    method filter(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<U>::_filter(this, 0, List<T>{}, p);
    }

    method map<U>(f: recursive? fn(_: T) -> U): List<U> {
        return List<U>::_map(this, 0, List<U>{}, f);
    }
}

//<summary>A Set entity.</summary>
//
//TODO: this is where we want to use POD when T POD
//
entity Set<T where Indexable> provides Object {
    hidden static _size(s: Set<T>): Int # _setsize
    hidden static _unsafe_at(s: Set<T>, i: Int): T # _setunsafe_at
    hidden static _unsafe_set(s: Set<T>, i: Int, v: T): Set<T> # _setunsafe_set
    hidden static _unsafe_add(s: Set<T>, v: T): Set<T> # _setunsafe_add
    hidden static _destructive_add(s: Set<T>, v: T): Set<T> # _setdestructive_add

    hidden static _unsafe_insert(s: Set<T>, i: Int, v: T): Set<T> # _setunsafe_insert
    hidden static _unsafe_remove(s: Set<T>, i: Int): Set<T> # _setunsafe_remove

    hidden recursive static _find(s: Set<T>, idx: Int, v: T): {found: Bool, pos: Int} {
        if(idx == Set<T>::_size(s)) {
            return {found=false, pos=idx};
        }

        var val = Set<T>::_unsafe_at(s, idx);
        if(Indexable::equal(val, v)) {
            return {found=true, pos=idx};
        }
        elif (Indexable::less(val, v)) {
            return {found=false, pos=idx};
        }
        else {
            return Set<T>::_find[recursive](s, idx + 1, v);
        }
    }

    method size(): Int {
        return Set<T>::_size(this);
    }
    
    method empty(): Bool {
        return Set<T>::_size(this) == 0;
    }
    
    method has(v: T): Bool {
        return Set<T>::_find(this, 0, v).found;
    }

    method insert(v: T): Set<T> {
        var loc = Set<T>::_find(this, 0, v);
        if(loc.found) {
            return Set<T>::_unsafe_set(this, loc.pos, v);
        }
        else {
            if(loc.pos == Set<T>::_size(this)) {
                return Set<T>::_unsafe_add(this, v);
            }
            else {
                return Set<T>::_unsafe_insert(this, loc.pos, v);
            }
        }
    }

    method remove(v: T): Set<T> {
        var loc = Set<T>::_find(this, 0, v);
        if(!loc.found) {
            return this;
        }
        else {
            return Set<T>::_unsafe_remove(this, loc.pos, v);
        }
    }
}

//<summary>A Map entity.</summary>
//
//TODO: this is where we want to use POD when T POD
//
entity Map<K where Indexable, V> provides Object {
    hidden static _size(m: Map<K, V>): Int # _mapsize
    hidden static _unsafe_at_key(m: Map<K, V>, i: Int): K # _mapunsafe_at_key
    hidden static _unsafe_at_val(m: Map<K, V>, i: Int): V # _mapunsafe_at_val
    hidden static _unsafe_set(m: Map<K, V>, i: Int, k: K, v: V): Map<K, V> # _mapunsafe_set
    hidden static _unsafe_add(m: Map<K, V>, k: K, v: V): Map<K, V> # _mapunsafe_add
    hidden static _destructive_add(m: Map<K, V>, k: K, v: V): Map<K, V> # _mapdestructive_add

    hidden static _unsafe_insert(m: Map<K, V>, i: Int, k: K, v: V): Map<K, V> # _mapunsafe_insert
    hidden static _unsafe_remove(m: Map<K, V>, i: Int): Map<K, V> # _mapunsafe_remove

    hidden recursive static _find(m: Map<K, V>, idx: Int, k: K): {found: Bool, pos: Int} {
        if(idx == Map<K, V>::_size(m)) {
            return {found=false, pos=idx};
        }

        var kv = Map<K, V>::_unsafe_at_key(m, idx);
        if(Indexable::equal(kv, k)) {
            return {found=true, pos=idx};
        }
        elif (Indexable::less(kv, k)) {
            return {found=false, pos=idx};
        }
        else {
            return Map<K, V>::_find[recursive](m, idx + 1, k);
        }
    }

    method size(): Int {
        return Map<K, V>::_size(this);
    }
    
    method empty(): Bool {
        return Map<K, V>::_size(this) == 0;
    }
    
    method has(key: K): Bool {
        return Map<K, V>::_find(this, 0, key).found;
    }

    method get(key: K): Bool {
        var loc = Map<K, V>::_find(this, 0, key);
        check loc.found;

        return Map<K,V>::_unsafe_at_val(this, loc.pos);
    }

    method set(key: K, val: V): Map<K, V> {
        var loc = Map<K, V>::_find(this, 0, key);
        if(loc.found) {
            return Map<K, V>::_unsafe_set(this, loc.pos, key, val);
        }
        else {
            if(loc.pos == Map<K, V>::_size(this)) {
                return Map<K, V>::_unsafe_add(this, key, val);
            }
            else {
                return Map<K, V>::_unsafe_insert(this, loc.pos, key, val);
            }
        }
    }

    method remove(key: K): Set<T> {
        var loc = Map<K, V>::_find(this, 0, key);
        if(!loc.found) {
            return this;
        }
        else {
            return Map<K, V>::_unsafe_remove(this, loc.pos);
        }
    }
}
