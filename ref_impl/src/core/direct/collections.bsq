//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the fluent core language
namespace NSCore;

//<summary>Type for representing all non-none values.</summary>
concept Collection<T> provides Object {
}

entity ListEntry<T> provides Object {
    field value: T;
    field tail: ListEntry<T>?;

     recursive method at(idx: Int): T {
        if(idx == 0) {
            return this.value;
        }
        else {
            var tl = this.tail;
            check tl != none;

            return tl->at[recursive](idx - 1);
        }
    }

    recursive method map<U>(f: recursive? fn(_: T) -> U): ListEntry<U> {
        var nvalue = f[recursive?](this.value);

        var tl = this.tail;
        if(tl == none) {
            return ListEntry<U>{value=nvalue, tail=none};
        }
        else {
            var ntail = tl->map<U>[recursive](f);
            return ListEntry<U>{value=nvalue, tail=ntail};
        }
    }
}

function _listcons<T>(size: Int, list: ListEntry<T>?): List<T> # _listcons

//<summary>A List entity.</summary>
entity List<T> provides Collection<T> {
    field size: Int;
    field list: ListEntry<T>?;

    const empty: List<T> = _listcons<T>(0, none);

    method size(): Int {
        return this.size;
    }
    
    method at(idx: Int): T {
        var tl = this.list;
        check idx < this.size && tl != none;

        return tl->at[recursive](idx);
    }

    method map<U>(f: recursive? fn(_: T) -> U): List<U> {
        var tl = this.list;
        if(tl == none) {
            return List<U>::empty;
        }
        else {
            return _listcons<U>(this.size, tl->map<U>[recursive](f));
        }
    }
}

entity Set<T where Indexable> provides Collection<T> {
    field value: T;
    field left: Set<T>?;
    field right: Set<T>?;
}