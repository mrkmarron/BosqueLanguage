//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive types used in the Bosque language
namespace NSCore;

//<summary>Special type which all values are instances of.</summary>
concept Any {
    method is<T>(): Bool # special_method
    method as<T>(): T # special_method

    method tryAs<T>(): T? # special_method
    method defaultAs<T>(default: T): T # special_method

    method isNone(): Bool # special_method
    method isSome(): Bool # special_method
}

//<summary>Special type for representing all non-none values.</summary>
concept Some provides Any {
    method update(): Some # special_method
    method merge(): Some # special_method
    method project<T>(): Some # special_method
    method tryProject<T>(): Some? # special_method
}

//<summary>Types that can be used in equality operations or in key based containers.</summary>
concept Indexable provides Any {
    static getKey(a: Indexable): KeyType # special_method
    static equal(a: Indexable, b: Indexable): Bool # special_method
}

//<summary>Types that can be ordered meaningfully operations.</summary>
concept Orderable provides Any {
    static compare<T where Orderable>(a: T, b: T): Bool # orderable_compare
}

//<summary>Special type for indicating this type supports typed string use.</summary>
concept Parsable provides Any {
    abstract static tryParse(str: String): Result<Any>;
}

//<summary>Special type that all Validator (regex etc.) types provide.</summary>
concept Validator provides Any {
}

//<summary>Special type for indicating a value can be used as a key in a collection.</summary>
concept KeyType provides Any, Indexable {
}

//<summary>Type for indicating that a datatype is Plain-Old-Data.</summary>
concept PODType provides Any, Parsable {
    static stringify<T where PODType>(data: T): StringOf<T> # pod_stringify
    static parseString<T where PODType>(str: StringOf<T>): T # pod_parsestring
    static tryParseString<T where PODType>(str: String): Result<T> # pod_tryparsestring

    static bufferify<T where PODType>(data: T, format?: BufferFormat, encoding?: BufferEncoding, compression?: BufferCompression): Buffer<T> # pod_bufferify
    static parseBuffer<T where PODType>(data: Buffer<T>): T # pod_parsebuffer

    static jsonify<T where PODType>(data: T): String # pod_jsonify
    static parseJSON<T where PODType>(str: String): T # pod_parsejson
    static tryParseJSON<T where PODType>(str: String): Result<T> # pod_tryparsejson

    override static tryParse(str: String): Result<Any> # pod_tryparse
}

//<summary>Type to unify Buffers and APITypes at top level for checking</summary>
concept APIValue provides Any {
}

//<summary>Type for indicating that a datatype can be exported as part of a stable API.</summary>
concept APIType provides APIValue, Parsable {
    static stringify<T where APIType>(data: T): StringOf<T> # api_stringify
    static parseString<T where APIType>(str: StringOf<T>): T # api_parsestring
    static tryParseString<T where APIType>(str: String): Result<T> # api_tryparsestring

    static bufferify<T where APIType>(data: T, format?: BufferFormat, encoding?: BufferEncoding, compression?: BufferCompression): Buffer<T> # api_bufferify
    static parseBuffer<T where APIType>(data: Buffer<T>): T # api_parsebuffer

    static jsonify<T where APIType>(data: T): String # api_jsonify
    static parseJSON<T where APIType>(str: String): T # api_parsejson
    static tryParseJSON<T where APIType>(str: String): Result<T> # api_tryparsejson

    override static tryParse(str: String): Result<Any> # api_tryparse
}

//<summary>Type for representing the none-value.</summary>
concept Truthy provides KeyType, PODType, APIType {
    override static tryParse(str: String): Result<Any> # truthy_tryparse
}

//<summary>Type for representing the none-value.</summary>
entity None provides Truthy {
    override static tryParse(str: String): Result<Any> # none_tryparse
}

//<summary>Primitive boolean value.</summary>
entity Bool provides Some, Truthy {
    override static tryParse(str: String): Result<Any> # bool_tryparse
}

//<summary>Primitive integer value.</summary>
entity Int provides KeyType, PODType, APIType, Orderable, Some {
    override static tryParse(str: String): Result<Any> # int_tryparse

    static max(v1: Int, v2: Int): Int {
        return v1 > v2 ? v1 : v2;
    }

    static min(v1: Int, v2: Int): Int {
        return v1 < v2 ? v1 : v2;
    }
}

//<summary>Primitive string value.</summary>
entity String provides KeyType, PODType, APIType, Orderable, Some {
    override static tryParse(str: String): Result<Any> # string_tryparse
}

//<summary>Primitive stringof value.</summary>
entity StringOf<T where Parsable | Validator> provides KeyType, Some, PODType when T provides PODType, APIType when T provides APIType {
    method rawString(): String # stringof_rawstring

    static asStringOf<T>(str: String): StringOf<T> # stringof_asstring
    static tryAsString<T>(str: String): StringOf<T>? # stringof_tryasstring

    method convertUp<U where T provides U>(): StringOf<U> # stringof_convertsub
    method tryConvertUp<U where T provides U>(): StringOf<U>? # stringof_tryconvertsub

    method convertDown<U where U provides T>(): StringOf<U> # stringof_convertsuper
    method tryConvertDown<U where U provides T>(): StringOf<U>? # stringof_tryconvertsuper
}

enum BufferFormat {
    Structured,
    Binary
}

enum BufferEncoding {
    UTF8,
    URI,
    Base64
}

enum BufferCompression {
    None,
    RLE,
    Time,
    Space
}

//<summary>An efficient buffer encoding for data.</summary>
entity Buffer<T where PODType | APIType> provides APIValue, Some {
}

//<summary>An efficient buffer encoding for data.</summary>
entity PODReadBuffer provides Some {
    static fromBuffer<T where PODType>(data: Buffer<T>): PODReadBuffer # podreadbuffer_frombuffer
    static fromStringOf<T where PODType(data: StringOf<T>): PODReadBuffer # podreadbuffer_fromstringof
    static fromString(data: String): PODReadBuffer # podreadbuffer_fromstring

    static read<T where PODType>(ref buf: PODReadBuffer): T # podreadbuffer_read
    static tryRead<T where PODType>(ref buf: PODReadBuffer): Result<T> # podreadbuffer_tryread

    static isArrayStart(buf: PODReadBuffer): Bool # podreadbuffer_isliststart
    static isArrayEnd(buf: PODReadBuffer): Bool # podreadbuffer_islistend
    static tryReadArrayStart(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadliststart
    static tryReadArrayEntry(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadlistentry
    static tryReadArrayEnd(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadlistend
    static readListAction<T>(ref buf: PODReadBuffer, f: fn(ref _: PODReadBuffer) -> T): List<T> # podreadbuffer_readlistaction

    static isDictStart(buf: PODReadBuffer): Bool # podreadbuffer_ismapstart
    static isDictEnd(buf: PODReadBuffer): Bool # podreadbuffer_ismapend
    static tryReadDictStart(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadmapstart
    static tryReadDictKey(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadmapkey
    static tryReadDictValue(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadmapvalue
    static tryReadDictEnd(ref buf: PODReadBuffer): Bool # podreadbuffer_tryreadmapend
    static readMapAction<K where Indexable, V>(ref buf: PODReadBuffer, f: fn(ref _: PODReadBuffer) -> MapEntry<K, V>): Map<K, V> # podreadbuffer_readmapaction
}

//<summary>An efficient buffer encoding for data.</summary>
entity PODWriteBuffer provides Some {
    static create(format?: BufferFormat, encoding?: BufferEncoding, compression?: BufferCompression): PODWriteBuffer # podwritebuffer_create
    complete<T where PODType>(): Buffer<T> # podwritebuffer_complete

    write<T where PODType>(data: T): PODWriteBuffer # podwritebuffer_write

    writeArrayStart(): PODWriteBuffer # podwritebuffer_writeliststart
    writeArrayEntry(): PODWriteBuffer # podwritebuffer_writelistentry
    writeArrayEnd(): PODWriteBuffer # podwritebuffer_writelistend
    writeListAction<T>(l: List<T>, fn(_: T, _: PODWriteBuffer) -> PODWriteBuffer): PODWriteBuffer # podwritebuffer_writelistaction

    writeDictStart(): PODWriteBuffer # podwritebuffer_writemapstart
    writeDictKey(): PODWriteBuffer # podwritebuffer_writemapkey
    writeDictValue(): PODWriteBuffer # podwritebuffer_writemapvalue
    writeDictEnd(): PODWriteBuffer # podwritebuffer_writemapend
    writeMapAction<K where Indexable, V>(m: Map<K, V>, fn(_: MapEnty<K, V>, _: PODWriteBuffer) -> PODWriteBuffer): PODWriteBuffer # podwritebuffer_writemapaction
}

//<summary>An efficient buffer encoding for data.</summary>
entity APIReadBuffer provides Some {
    static fromBuffer<T where APIType>(data: Buffer<T>): APIReadBuffer # apireadbuffer_frombuffer
    static fromStringOf<T where APIType>(data: StringOf<T>): APIReadBuffer # apireadbuffer_fromstringof
    static fromString(data: String): APIReadBuffer # apireadbuffer_fromstring

    static read<T where APIType>(ref buf: APIReadBuffer): T # apireadbuffer_read
    static tryRead<T where APIType>(ref buf: APIReadBuffer): Result<T> # apireadbuffer_tryread

    static isArrayStart(buf: APIReadBuffer): Bool # apireadbuffer_isliststart
    static isArrayEnd(buf: APIReadBuffer): Bool # apireadbuffer_islistend
    static tryReadArrayStart(ref buf: APIReadBuffer): Bool # apireadbuffer_tryreadliststart
    static tryReadArrayEntry(ref buf: APIReadBuffer): Bool # apireadbuffer_tryreadlistentry
    static tryReadArrayEnd(ref buf: APIReadBuffer): Bool # apireadbuffer_tryreadlistend
    static readListAction<T>(ref buf: APIReadBuffer, f: fn(ref _: APIReadBuffer) -> T): List<T> # apireadbuffer_readlistaction

    static isDictStart(buf: APIReadBuffer): Bool # apireadbuffer_ismapstart
    static isDictEnd(buf: APIReadBuffer): Bool # apireadbuffer_ismapend
    static tryReadDictStart(ref buf: APIReadBuffer): Bool # apireadbuffer_tryreadmapstart
    static tryReadDictKey(ref buf: APIReadBuffer): K # apireadbuffer_readmapkey
    static tryReadDictValue(ref buf: APIReadBuffer): V # apireadbuffer_readmapvalue
    static tryReadDictEnd(ref buf: APIReadBuffer): Bool # apireadbuffer_tryreadmapend
    static readMapAction<K where Indexable, V>(ref buf: APIReadBuffer, f: fn(ref _: APIReadBuffer) -> MapEntry<K, V>): Map<K, V> # apireadbuffer_readmapaction
}

//<summary>An efficient buffer encoding for data.</summary>
entity APIWriteBuffer provides Some {
    static create(format?: BufferFormat, encoding?: BufferEncoding, compression?: BufferCompression): APIWriteBuffer # apiwritebuffer_create
    complete<T where APIType>(): Buffer<T> # apiwritebuffer_complete

    write<T where APIType>(data: T): APIWriteBuffer # apiwritebuffer_write

    writeListStart(): APIWriteBuffer # apiwritebuffer_writeliststart
    writeListEntry(): APIWriteBuffer # podwritebuffer_writelistentry
    writeListEnd(): APIWriteBuffer # apiwritebuffer_writelistend
    writeListAction<T>(l: List<T>, fn(_: T, _: APIWriteBuffer) -> APIWriteBuffer): APIWriteBuffer # apiwritebuffer_writelistaction

    writeDictStart(): APIWriteBuffer # apiwritebuffer_writemapstart
    writeDictKey(): APIWriteBuffer # apiwritebuffer_writemapkey
    writeDictValue(): APIWriteBuffer # apiwritebuffer_writemapvalue
    writeDictEnd(): APIWriteBuffer # apiwritebuffer_writemapend
    writeMapAction<K where Indexable, V>(m: Map<K, V>, fn(_: MapEnty<K, V>, _: APIWriteBuffer) -> APIWriteBuffer): APIWriteBuffer # apiwritebuffer_writemapaction
}

//<summary>Primitive GUID value.</summary>
entity GUID provides KeyType, PODType, APIType, Some {
    override static tryParse(str: String): Result<Any> # guid_tryparse
}

//<summary>Primitive ISO standard date time value.</summary>
entity ISOTime provides KeyType, PODType, APIType, Orderable, Some {
    override static tryParse(str: String): Result<Any> # time_tryparse
}

//<summary>All actual ordered event times implicitly provide this.</summary>
concept EventTime provides KeyType, APIType, Orderable, Some {
}

//<summary>All actual enums implicitly provide this.</summary>
concept Enum provides KeyType, APIType, Some {
}

//<summary>All actual custom keys implicitly provide this.</summary>
concept IdKey provides KeyType, APIType, Some {
}

//<summary>Special category of IdKey for state hashes or Ids (to mirror event time option for state management).</summary>
concept StateIdKey provides IdKey {
}

//<summary>Primitive regex value.</summary>
entity Regex provides Some {
    method test(str: String, start?: Int, end?: Int): Bool # regex_match

    //
    //TODO: this is pretty boring right now
    //
}

//<summary>All actual tuples implicitly provide this concept.</summary>
concept Tuple provides Some {
}

//<summary>All actual Key tuples implicitly provide this concept.</summary>
concept KeyTuple provides KeyType, Tuple {
}

//<summary>All actual POD tuples implicitly provide this concept.</summary>
concept PODTuple provides PODType, Tuple {
    override static tryParse(str: String): Result<Any> # podtuple_tryparse
}

//<summary>All actual POD tuples implicitly provide this concept.</summary>
concept APITuple provides APIType, Tuple {
    override static tryParse(str: String): Result<Any> # apituple_tryparse
}

//<summary>All actual records implicitly provide this concept.</summary>
concept Record provides Some {
}

//<summary>All actual Key records implicitly provide this concept.</summary>
concept KeyRecord provides KeyType, Record {
}

//<summary>All actual POD records implicitly provide this concept.</summary>
concept PODRecord provides POD, Record {
    override static tryParse(str: String): Result<Any> # podrecord_tryparse
}

//<summary>All actual POD records implicitly provide this concept.</summary>
concept APIRecord provides APIType, Record {
    override static tryParse(str: String): Result<Any> # apituple_tryparse
}

//<summary>All actual entities/concepts implicitly provide this concept.</summary>
concept Object provides Some {
}

//<summary>Providing this concept allows for an entity to be compared or stored in a key based container using the key field.</summary>
entity Result<T> provides Some {
    hidden field _success: Bool;
    hidden field _result: T?;
    hidden field _err: Any;

    factory static error(info?: Any): { _success: Bool, _result: T?, _err: Any } {
        return { _success=false, _result=none, _err=(info ?| none)};
    }

    factory static success(result: T): { _success: Bool, _result: T? } {
        return { _success=true, _result=result, _err=none };
    }

    method isError(): Bool {
        return !this._success;
    }

    method isSuccess(): Bool {
        return this._success;
    }

    method getResult(): T {
        check this._success;
        return this._result->as<T>();
    }

    method getErrorInfo(): Any {
        check !this._success;
        return this._err;
    }

    method convertUp<U where T provides U>(): Result<U> # result_convertsub

    method convertDown<U where U provides T>(): Result<U> # result_convertsuper
    method tryConvertDown<U where U provides T>(): Result<U>? # result_tryconvertsuper
}

//<summary>A pure concept defining useful static numerical operations.</summary>
concept Math {
    static mult(a: Int, b: Int): Int # math_mult
    static div(a: Int, b: Int): Int # math_div
    static mod(a: Int, b: Int): Int # math_mod
}

//<summary>Providing this concept allows for an entity to be compared or stored in a key based container using the key field.</summary>
concept Keyed<T where KeyType> provides Indexable, Some {
    field key: T;
}

//<summary>A lightweight tagging class for values.</summary>
entity Tagged<T where KeyType, U> provides Keyed<T>, Object {
    field value: U;
}
