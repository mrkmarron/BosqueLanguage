//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity AbstractMap<K where Indexable, V> provides Object {
    abstract method size(): Int;
    abstract method empty(): Bool;

    abstract method keys(): List<K>;
    abstract method keySet(): Set<K>;
    abstract method values(): List<K>;
    abstract method entries(): List<MapEntry<K, V>>;

    abstract method has(key: K): Bool;
    abstract method hasAll(...ks: List<K>): Bool;

    abstract method domainIncludes(s: Set<T>): Bool;

    abstract method get(key: K): V;
    abstract method tryGet(k: K): V?;
}

entity Map<K where Indexable, V> provides AbstractMap<K, V>, PODType when K grounded PODType && V grounded PODType, APIType when K grounded APIType && V grounded APIType {
    hidden static _size(m: Map<K, V>): Int # map_size
    hidden static _has_key(m: Map<K, V>, key: K!KeyType): Bool # map_has_key
    hidden static _at_key(m: Map<K, V>, key: K!KeyType): K # map_at_key
    hidden static _at_val(m: Map<K, V>, key: K!KeyType): V # map_at_val

    hidden static _get_keylist(m: Map<K, V>): KeyList<K!KeyType>? # map_get_keylist
    
    hidden static _unsafe_add(m: Map<K, V>, k: K!KeyType, key: K, val: V, newkl: KeyList<K!KeyType>): Map<K, V> # map_unsafe_add
    hidden static _unsafe_update(m: Map<K, V>, k: K!KeyType, key: K, val: V): Map<K, V> # map_unsafe_update

     hidden static _add(m: Map<K, V>, k: K, v: V): Map<K, V>
        requires release !Map<K, V>::_has_key(m, Indexable::getKey(k));
    {
        let kk = Indexable::getKey(k);
        let kl = Map<K, V>::_get_keylist(m);
        return Map<K, V>::_unsafe_add(m, kk, k, v, KeyList<T!KeyType>@{hkey=kk, tail=kl});
    }

     hidden static _update(m: Map<K, V>, k: K, v: V): Map<K, V>
        requires release Map<K, V>::_has_key(m, Indexable::getKey(k));
     {
        let kk = Indexable::getKey(k);
        return Map<K, V>::_unsafe_update(m, kk, k, v);
    }

    hidden recursive static _key_list(m: Map<K, V>, kl: KeyList<K!KeyType>?, l: List<K>): List<K> {
        if(kl == none) {
            return l;
        }
        else {
            let v = Map<K, V>::_at_key(m, kl.hkey);
            return Map<K, V>::_key_list[recursive](m, KeyList<K!KeyType>::_get_tail(kl), List<T>::_unsafe_push(l, v));
        }
    }

    //we should be able to take keyset and key array for the set directly
    hidden static _key_set(m: Map<K, V>): Set<K> # map_keyset

    //we should be able to use the array map operation on the has has arrays
    hidden static _domainincludes(m: Map<K, V>, s: Set<K>): Bool # map_domainincludes

    hidden recursive static _value_list(m: Map<K, V>, kl: KeyList<K!KeyType>?, l: List<V>): List<V> {
        if(kl == none) {
            return l;
        }
        else {
            let v = Map<K, V>::_at_val(m, kl.hkey);
            return Map<K, V>::_value_list[recursive](m, KeyList<K!KeyType>::_get_tail(kl), List<T>::_unsafe_push(l, v));
        }
    }

    hidden recursive static _entries_list(m: Map<K, V>, kl: KeyList<K!KeyType>?, l: List<MapEntry<K, V>>): List<MapEntry<K, V>> {
        if(kl == none) {
            return l;
        }
        else {
            let k = Map<K, V>::_at_key(m, kl.hkey);
            let v = Map<K, V>::_at_val(m, kl.hkey);
            return Map<K, V>::_value_list[recursive](m, KeyList<K!KeyType>::_get_tail(kl), List<T>::_unsafe_push(l, MapEntry<K, V>@{ key=key, value=value }));
        }
    }

    hidden recursive static _hasall(m: Map<K, V>, l: List<K>, idx: Int): Bool {
        if(idx == List<K>::_size(l)) {
            return true;
        }
        else {
            let v = List<K>::_unsafe_get(l, idx);
            let kk = Indexable::getKey(v);
            if(!Map<K, V>::_has_key(m, kk)) {
                return false;
            }
            else {
                return Map<K, V>::_hasall[recursive](m, l, idx + 1);
            }
        }
    }

    hidden recursive static _submap(m: Map<K, V>, kl: KeyList<K!KeyType>?, mp: Map<K, V>, p: recursive? fn(_: K, _: V) -> Bool): Map<K, V> {
        if(kl == none) {
            return mp;
        }
        else {
            let kk = kl.hkey;
            let k = Map<K, V>_at_key(m, kk);
            let v = Map<K, V>_at_val(m, kk);

            if(!p[recursive?](k, v)) {
                return Map<K, V>::_submap(kl.tail, mp, p);
            }
            else {
                return Map<K, V>::_submap(kl.tail, Map<K, V>::_add(mp, k, v), p);
            }
        }
    }

    //lets steal the keylist and has array from s and pop them into the new map (some junk remains in the key/val arrays but we never look at it)
    hidden static _projectDomain(m: Map<K, V>, s: Set<K>): Map<K, V> # map_projectdomain

    hidden recursive static _remap<U>(m: Map<K, V>, kl: KeyList<K!KeyType>?, mp: Map<K, U>, f: recursive? fn(_: K, _: V) -> U): Map<K, U> {
        if(kl == none) {
            return mp;
        }
        else {
            let kk = kl.hkey;
            let k = Map<K, V>_at_key(m, kk);
            let v = Map<K, V>_at_val(m, kk);

            let u = f[recursive?](k, v);
             return Map<K, V>::_remap(kl.tail, Map<K, V>::_add(mp, k, u), f);
        }
    }

    hidden recursive static _projectkeys(m: Map<K, V>, l: List<K>, mp: Map<K, V>, idx: Int): Bool {
        if(idx == List<K>::_size(l)) {
            return mp;
        }
        else {
            let lv = List<K>::_unsafe_get(l, idx);
            let kk = Indexable::getKey(lv);

            if(!Map<K, V>::_has_key(m, kk)) {
                return Map<K, V>::_projectkeys[recursive](m, l, mp, idx + 1);
            }
            else {
                let k = Map<K, V>_at_key(m, kk);
                let v = Map<K, V>_at_val(m, kk);

                return Map<K, V>::_projectkeys[recursive](m, l, Map<K, V>::_add(mp, k, v), idx + 1);
            }
        }
    }

    override method size(): Int {
        return Map<K, V>::_size(this);
    }

    override method empty(): Bool {
        return Map<K, V>::_size(this) == 0;
    }

    override method keys(): List<K> {
        return Map<K, V>::_key_list(this, Map<K, V>::_get_keylist(this)->reverse(), List<K>@{});
    }

    override method keySet(): Set<K> {
        return Map<K, V>::_key_set(this);
    }

    override method values(): List<K> {
        return Map<K, V>::_value_list(this, Map<K, V>::_get_keylist(this)->reverse(), List<V>@{});
    }

    override method entries(): List<MapEntry<K, V>> {
        return Map<K, V>::_entry_list(this, Map<K, V>::_get_keylist(this)->reverse(), List<MapEntry<K, V>>@{});
    }

    method toDynamicMap(): DynamicMap<K, V> {
        abort;
    }

    override method has(key: K): Bool {
        return Map<K, V>::_has_key(this, Indexable::getKey(k))
    }

    override method hasAll(...kl: List<K>): Bool {
        return Map<K, V>::_hasall[recursive](this, kl, 0);
    }

    override method domainIncludes(s: Set<K>): Bool {
        if(Set<K>::_size(s) > Map<K, V>::_size(this)) {
            return false;
        }
        else {
            return Map<K, V>::_domainincludes(this, s);
        }
    }

    override method get(key: K): V 
        requires release Map<K, V>::_has_key(this, Indexable::getKey(k));
    {
        return Map<K, V>::_at_val(this, Indexable::getKey(k));
    }

    override method tryGet(k: K): V? {
        return Map<K, V>::_has_key(this, Indexable::getKey(k)) ? Map<K, V>::_at_val(this, Indexable::getKey(k)) : none;
    }

    method submap(p: recursive? fn(_: K, _: V) -> Bool): Map<K, V> {
        return Map<K, V>::_submap[recursive](this, Map<K, V>::_get_keylist(this)->reverse(), Map<K, V>@{}, p);
    }

    method projectDomain(ds: Set<K>): Map<K, V> {
        return Map<K, V>::_projectDomain(this, ds);
    }

    method remap<U>(f: recursive? fn(_: K, _: V) -> U): Map<K, U> {
        return Map<K, V>::_remap<U>[recursive](this, Map<K, V>::_get_keylist(this)->reverse(), Map<K, U>@{}, f);
    }

    method projectKeys(...kl: List<K>): Map<K, V> {
        return Map<K, V>::_projectkeys[recursive](this, kl, Map<K, V>@{}, 0);
    }

    method unionWith(m: Map<K, V>): Map<K, V> {

    }

    static union(...ml: List<Map<K, V>>): Map<K, V> {

    }

    method mergeWith(m: Map<K, V>): Map<K, V> {

    }

    static merge(...ml: List<Map<K, V>>): Map<K, V> {

    }
}

entity DynamicMap<K where Indexable, V> provides AbstractMap<K, V> {
    override method size(): Int;
    override method empty(): Bool;

    override method keys(): List<K>;
    override method keySet(): Set<K>;
    override method values(): List<K>;
    override method entries(): List<MapEntry<K, V>>;

    method toMap(): DynamicMap<K, V> {
        abort;
    }

    override method has(key: K): Bool;
    override method hasAll(...ks: List<K>): Bool;

    override method get(key: K): V;
    override method tryGet(k: K): V?;

add(k: K, v: V): DynamicMap<K, V>
addAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V>

insert(k: K, v: V): DynamicMap<K, V>
insertAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V>

update(k: K, v: V): DynamicMap<K, V>
updateAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V>

remove(k: K): DynamicMap<K, V>
removeAll(...kl: List<K>): DynamicMap<K, V>

}


