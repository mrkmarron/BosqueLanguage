//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity List<T> provides Object, PODType when T grounded PODType, APIType when T grounded APIType {
    hidden static _size(l: List<T>): Int # list_size
    hidden static _unsafe_get(l: List<T>, i: Int): T # list_unsafe_get

    hidden static _unsafe_push(l: List<T>, v: T): T # list_unsafe_push
    hidden static _unsafe_set(l: List<T>, idx: Int, v: T): T # list_unsafe_set
    
    hidden recursive static _all(l: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): Bool {
        if(idx == List<T>::_size(l)) {
            return true;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return false;
            }
            else {
                return List<T>::_all[recursive](l, idx + 1, p);
            }
        }
    }

    hidden recursive static _indexof(l: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool, end: Int): Int {
        if(idx == end) {
            return idx;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return idx;
            }
            else {
                return List<T>::_indexof[recursive](l, idx + 1, p, end);
            }
        }
    }

    hidden recursive static _indexoflast(l: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool, start: Int): Int {
        if(idx == start - 1) {
            return idx;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return idx;
            }
            else {
                return List<T>::_indexoflast[recursive](l, idx - 1, p, start);
            }
        }
    }

    hidden recursive static _count(l: List<T>, idx: Int, acc: Int, p: recursive? fn(_: T) -> Bool): Int {
        if(idx == List<T>::_size(l)) {
            return acc;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let nacc = p[recursive?](val) ? acc + 1 : acc;
            
            return List<T>::_count[recursive](l, idx + 1, nacc, p);
        }
    }

    hidden recursive static {when T KeyType} _indexof_keytype(l: List<T>, idx: Int, cv: T, end: Int): Int {
        if(idx == end) {
            return idx;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(cv == val) {
                return idx;
            }
            else {
                return List<T>::_indexof_keytype[recursive](l, idx + 1, cv, end);
            }
        }
    }

    hidden recursive static {when T KeyType} _indexoflast_keytype(l: List<T>, idx: Int, cv: T, start: Int): Int {
        if(idx == start - 1) {
            return idx;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(cv == val) {
                return idx;
            }
            else {
                return List<T>::_indexoflast_keytype[recursive](l, idx - 1, cv, start);
            }
        }
    }

    hidden recursive static {when T KeyType} _count_keytype(l: List<T>, idx: Int, acc: Int, cv: T): Int {
        if(idx == List<T>::_size(l)) {
            return acc;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let nacc = (cv == val) ? acc + 1 : acc;
            
            return List<T>::_count_keytype[recursive](l, idx + 1, nacc, cv);
        }
    }

    hidden recursive static {when T Int} _min(l: List<T>, idx: Int, acc: Int): Int {
        if(idx == List<T>::_size(l)) {
            return acc;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_min[recursive](l, idx + 1, acc < val ? acc : val);
        }
    }

    hidden recursive static {when T Int} _max(l: List<Int>, idx: Int, acc: Int): Int {
        if(idx == List<T>::_size(l)) {
            return List<T>::_size(l);
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_max[recursive](l, idx + 1, acc > val ? acc : val);
        }
    }

    hidden recursive static {when T Int} _sum(l: List<Int>, idx: Int, acc: Int): Int {
        if(idx == List<T>::_size(l)) {
            return acc;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_sum[recursive](l, idx + 1, acc + val);
        }
    }


    hidden recursive static _filter(l: List<T>, lp: List<U>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return List<T>::_filter(l, List<T>::_unsafe_push(lp, val), idx + 1, p);
            }
            else {
                return List<T>::_filter(l, lp, idx + 1, p);
            }
        }
    }

    hidden recursive static _ofttype<U>(l: List<T>, lp: List<U>, idx: Int): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(val->is<U>()) {
                return List<T>::_ofttype<U>(l, List<U>::_unsafe_push(lp, val->as<U>()), idx + 1);
            }
            else {
                return List<T>::_ofttype<U>(l, lp, idx + 1);
            }
        }
    }

    hidden recursive static _cast<U>(l: List<T>, lp: List<U>, idx: Int): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_cast<U>(l, List<U>::_unsafe_push(lp, val->as<U>()), idx + 1);
        }
    }

    hidden recursive static _takek(l: List<T>, lp: List<T>, idx: Int, k: Int): List<T> {
        if(k == 0) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_takek<U>(l, List<T>::_unsafe_push(lp, val), idx + 1, k - 1);
        }
    }

    hidden recursive static _slice(l: List<T>, start: Int, end: Int): List<T> {
        return List<T>::_takek(l, List<T>@{}, start, end - start);
    }

    hidden recursive static _takewhile(l: List<T>, lp: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return lp;
            }
            else {
                return List<T>::_takewhile(l, List<T>::_unsafe_push(lp, val), idx + 1, p);
            }
        }
    }

    hidden recursive static _discardwhile(l: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return List<T>@{};
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return List<T>::_discardwhile(l, idx + 1, p);
            }
            else {
                return List<T>::_takek(l, List<T>@{}, idx, List<T>::_size(l) - idx)
            }
        }
    }

    hidden recursive static _takeuntil(l: List<T>, lp: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(p[recursive?](val)) {
                return lp;
            }
            else {
                return List<T>::_takeuntil(l, List<T>::_unsafe_push(lp, val), idx + 1, p);
            }
        }
    }

    hidden recursive static _discarduntil(l: List<T>, idx: Int, p: recursive? fn(_: T) -> Bool): List<T> {
        if(idx == List<T>::_size(l)) {
            return List<T>@{};
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            if(!p[recursive?](val)) {
                return List<T>::_discarduntil(l, idx + 1, p);
            }
            else {
                return List<T>::_takek(l, List<T>@{}, idx, List<T>::_size(l) - idx)
            }
        }
    }

    hidden recursive static {when T KeyType} _unique(l: List<T>, lp: List<T>, idx: Int): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let has = List<T>::_indexof_keytype[recursive](lp, 0, val, List<T>::_size(lp)) != List<T>::_size(lp);
            if(has) {
                return List<T>::_unique(l, lp, idx + 1);
            }
            else {
                return List<T>::_unique(l, List<T>::_unsafe_push(lp, val), idx + 1);
            }
        }
    }

    hidden recursive static _reverse(l: List<T>, lp: List<T>, idx: Int): List<T> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_reverse(l, List<T>::_unsafe_set(lp, (List<T>::_size(l) - 1) - idx, val), idx + 1);
        }
    }

    hidden recursive static _map<U>(l: List<T>, lp: List<U>, idx: Int, f: recursive? fn(_: T) -> U): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_map<U>(l, List<T>::_unsafe_push(lp, f[recursive?](val)), idx + 1, f);
        }
    }

    hidden recursive static _mapIndex<U>(l: List<T>, lp: List<U>, idx: Int, f: recursive? fn(_: Int, _: T) -> U): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_mapIndex<U>(l, List<T>::_unsafe_push(lp, f[recursive?](idx, val)), idx + 1, f);
        }
    }

    hidden recursive static {when T KeyType} _projectWMap<U>(l: List<T>, lp: List<U>, idx: Int, m: Map<T, U>): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_projectWMap<U>(l, List<T>::_unsafe_push(lp, m->get(val)), idx + 1);
        }
    }

    hidden recursive static {when T KeyType} _tryProjectWMap<U>(l: List<T>, lp: List<U>, idx: Int, m: Map<T, U>): List<U> {
        if(idx == List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_tryProjectWMap<U>[recursive](l, List<T>::_unsafe_push(lp, m->tryGet(val)), idx + 1);
        }
    }

    hidden recursive static _zipIndex(l: List<T>, lp: List<[Int, T]>, idx: Int): List<[Int, T]> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_zipIndex[recursive](l, List<T>::_unsafe_push(lp, [idx, val]), idx + 1);
        }
    }

    hidden recursive static _joinSingle<U>(v: T, ol: List<U>, lp: List<[T, U]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<[T, U]> {
        if(idx === List<T>::_size(ol)) {
            return lp;
        }
        else {
            let val = List<U>::_unsafe_get(ol, idx);
            if(p[recursive?](v, val)) {
                return List<T>::_joinSingle<U>[recursive](v, List<[T, U]>::_unsafe_push(lp, [v, val]), idx + 1, p);
            }
            else {
                return List<T>::_joinSingle<U>[recursive](v, lp, idx + 1, p);
            }
        }
    }

    hidden recursive static _join<U>(l: List<T>, ol: List<U>, lp: List<[T, U]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<[T, U]> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let jl = List<T>::_joinSingle<U>[recursive](val, ol, lp, 0, p);

            return List<T>::_join<U>[recursive](l, ol, lp, idx + 1, p);
        }
    }

    hidden recursive static _joinGroupSingle<U>(v: T, ol: List<U>, lp: List<[T, List<U>]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<[T, U]> {
        if(idx === List<T>::_size(ol)) {
            return lp;
        }
        else {
            let val = List<U>::_unsafe_get(ol, idx);
            if(p[recursive?](v, val)) {
                return List<T>::_joinGroupSingle<U>[recursive](v, List<T>::_unsafe_push(lp, [v, val]), idx + 1, p);
            }
            else {
                return List<T>::_joinGroupSingle<U>[recursive](v, lp, idx + 1, p);
            }
        }
    }

    hidden recursive static _joinGroup<U>(l: List<T>, ol: List<U>, lp: List<[T, List<U>]>, idx: Int, p: recursive? fn(_: T, _: U) -> Bool): List<[T, List<U>]> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let jl = List<T>::_joinGroupSingle<U>[recursive](val, ol, List<[T, List<U>]>, 0, p);

            return List<T>::_joinGroup<U>[recursive](l, ol, List<T>::_unsafe_push(lp, jl), idx + 1, p);
        }
    }

    hidden recursive static _append(l: List<T>, lp: List<T>, idx: Int): List<T> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            return List<T>::_append[recursive](l, List<T>::_unsafe_push(lp, val), idx + 1);
        }
    }

    hidden recursive static _partitionSingle<K where K KeyType>(kk: K, ol: List<T>, lp: List<T>, idx: Int, pf: recursive? fn(_: T) -> K): List<T> {
        if(idx === List<T>::_size(ol)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(ol, idx);
            let key = pf[recursive?](val);
            if(kk == key) {
                return List<T>::_partitionSingle[recursive](kk, ol, List<T>::_unsafe_push(lp, val), idx + 1, pf);
            }
            else {
                return List<T>::_partitionSingle[recursive](kk, ol, lp, idx + 1, pf);
            }
        }
    }

    hidden recursive static _partition<K where K KeyType>(l: List<T>, mp: Map<K, List<T>>, idx: Int, pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let key = pf[recursive?](val);
            if(Map<K, List<T>>::_has(key)) {
                return List<T>::_partition(l, mp, idx + 1, pf);
            }
            else {
                let pfg = List<T>::_partitionSingle<K>(key, l, List<T>@{}, idx, pf);
                return List<T>::_partition(l, mp->add(val, pfg), idx + 1, pf);
            }
        }
    }

    hidden recursive static _sort(this, List<T>@{}, 0, pf) {
        abort;
    }

    hidden recursive static _toMap<K, V>(l: List<T>, mp: Map<K, V>, idx: Int, kf: recursive? fn(_: T) -> K, vf: recursive? fn(_: T) -> V, merge?: Bool): Map<K, V> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let k = kf[recursive?](val);
            let v = vf[recursive?](val);

            if(merge) {
                return List<T>::_toMap(l, map->insert(k, v), idx + 1, kf, vf);
            }
            else {
                return List<T>::_toMap(l, map->add(k, v), idx + 1, kf, vf);
            }
        }
    }

    hidden recursive static _toIndexMap<V>(l: List<T>, mp: Map<Int, V>, idx: Int, vf: recursive? fn(_: T) -> V): Map<Int, V> {
        if(idx === List<T>::_size(l)) {
            return lp;
        }
        else {
            let val = List<T>::_unsafe_get(l, idx);
            let v = vf[recursive?](val);

            return List<T>::_toMap(l, mp->add(idx, v), idx + 1, kf, vf);
        }
    }

    hidden _rangeInBounds(start?: Int, end?: Int): Bool {
        let s, e = start ?| 0, end ?| List<T>::_size(this);
        return 0 <= s && s <= e && e <= List<T>::_size(this); 
    }

    method size(): Int {
        return List<T>::_size(this);
    }

    method empty(): Int {
        return List<T>::_size(this) == 0;
    }

    method front(): T 
        requires release List<T>::_size(this) != 0;
    {
        return List<T>::_unsafe_get(this, 0);
    }

    method tryFront(): T? {
        return List<T>::_size(this) != 0 ? List<T>::_unsafe_get(this, 0) : none;
    }

    method last(): T 
        requires release List<T>::_size(this) != 0;
    {
        List<T>::_unsafe_get(this, List<T>::_size(this) - 1);
    }

    method tryLast(): T? {
        return List<T>::_size(this) != 0 ? List<T>::_unsafe_get(this, List<T>::_size(this) - 1) : none;
    }

    method get(i: Int): T 
        requires release 0 <= idx && idx < List<T>::_size(this);
    {
        return List<T>::_unsafe_get(this, idx);
    }

    method tryGet(i: Int): T? {
        return 0 <= idx && idx < List<T>::_size(this) ? List<T>::_unsafe_get(this, idx) : none;
    }

    method single(p: recursive? fn(_: T) -> Bool): Bool 
        requires release List<T>::_size(this) != 0;
    {
        let idx = List<T>::_indexof[recursive](this, 0, p, List<T>::_size(this));
        let lastidx = List<T>::_indexoflast[recursive](this, List<T>::_size(this) - 1, p, 0);

        check lastidx == idx;
        return List<T>::_unsafe_get(this, idx);
    }

    method trySingle(p: Pred<T>, start?: Int, end?: Int): T? {
        let idx = List<T>::_indexof[recursive](this, 0, p, List<T>::_size(this));
        let lastidx = List<T>::_indexoflast[recursive](this, List<T>::_size(this) - 1, p, 0);

        return idx == lastidx ? List<T>::_unsafe_get(this, idx) : none;
    }

    method uniform(i: Int, start?: Int, end?: Int): T
        requires release List<T>::_size(this) != 0;
        requires release this->_rangeInBounds(start, end);
    {
        abort;
    }

    method allof(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::_size(this) == 0 || List<T>::_all[recursive](this, 0, p, List<T>::_size(this));
    }

    method noneof(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::_size(this) == 0 || List<T>::_indexof[recursive](this, 0, p, List<T>::_size(this)) == List<T>::_size(this);
    }

    method anyof(p: recursive? fn(_: T) -> Bool): Bool {
        return List<T>::_size(this) != 0 && List<T>::_indexof[recursive](this, 0, p, List<T>::_size(this)) != List<T>::_size(this);
    }

    method countIf(p: recursive? fn(_: T) -> Bool): Int {
        return List<T>::_count[recursive](this, 0, 0, p, List<T>::_size(this));
    }

    method {when T KeyType} contains(v: T): Bool {
        return List<T>::_indexof_keytype[recursive](this, 0, v, List<T>::_size(this)) != List<T>::_size(this);
    }

    method {when T KeyType} count(v: T): Int {
        return List<T>::_count_keytype[recursive](this, 0, 0, v, List<T>::_size(this));
    }

    method {when T Int} min(): Int 
        requires release List<T>::_size(this) != 0;
    {
        return List<T>::_min[recursive](this, 1, List<T>::_unsafe_get(0));
    }

    method {when T Int} tryMin(): Int? {
        return List<T>::_size(this) != 0 ? List<T>::_min[recursive](this, 1, List<T>::_unsafe_get(0)) : none;
    }

    method {when T Int} max(): Int 
        requires release List<T>::_size(this) != 0;
    {
        return List<T>::_max[recursive](this, 1, List<T>::_unsafe_get(0));
    }

    method {when T Int} tryMax(): Int? {
        return s != e ? List<T>::_max[recursive](this, 1, List<T>::_unsafe_get(0)) : none;
    }

    method {when T Int} sum(): Int {
        return List<T>::_sum[recursive](this, 0, 0, List<T>::_size(this));
    }

    method find(p: recursive? fn(_: T) -> Bool): T {
        let idx = List<T>::_indexof[recursive](this, 0, p, List<T>::_size(this));
        check idx != List<T>::_size(this);
        return List<T>::_unsafe_get(this, idx);
    }

    method tryFind(p: recursive? fn(_: T) -> Bool): T? {
        let idx = List<T>::_indexof[recursive](this, 0, p, List<T>::_size(this));
        return idx != List<T>::_size(this) ? List<T>::_unsafe_get(this, idx) : none;
    }

    method findLast(p: recursive? fn(_: T) -> Bool): T {
        let idxlast = List<T>::_indexoflast[recursive](this, List<T>::_size(this) - 1, p, 0);
        check idxlast != -1;
        return List<T>::_unsafe_get(this, idxlast);
    }

    method tryFindLast(p: recursive? fn(_: T) -> Bool): T? {
        let idxlast = List<T>::_indexoflast[recursive](this, List<T>::_size(this) - 1, p, 0);
        return idxlast != -1 ? List<T>::_unsafe_get(this, idxlast) : none;
    }

    method findIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idx = List<T>::_indexof[recursive](this, s, p, e);
        check idx != e;
        return idx;
    }

    method tryFindIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int?
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idx = List<T>::_indexof[recursive](this, s, p, e);
        return idx != e ? idx : none;
    }

    method findLastIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idxlast = List<T>::_indexoflast[recursive](this, e - 1, p, s);
        check idxlast != s - 1;
        return idxlast;
    }

    method tryFindLastIndexOf(p: recursive? fn(_: T) -> Bool, start?: Int, end?: Int): Int?
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idxlast = List<T>::_indexoflast[recursive](this, e - 1, p, s);
        return idxlast != s - 1 ? idxlast : none;
    }

    method {when T KeyType} indexOf(v: T, start?: Int, end?: Int): Int
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idx = List<T>::_indexof_keytype[recursive](this, s, v, e);
        check idx != e;
        return idx;
    }

    method {when T KeyType} tryIndexOf(v: T, start?: Int, end?: Int): Int?
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idx = List<T>::_indexof_keytype[recursive](this, s, v, e);
        return idx != e ? idx : none;
    }

    method {when T KeyType} lastIndexOf(v: T, start?: Int, end?: Int): Int
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idx = List<T>::_indexoflast_keytype[recursive](this, e - 1, v, s);
        check idx != s - 1;
        return idx;
    }

    method {when T KeyType} tryLastIndexOf(v: T, start?: Int, end?: Int): Int?
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        let idx = List<T>::_indexoflast_keytype[recursive](this, e - 1, v, s);
        return idx != s - 1 ? idx : none;
    }

    method filter(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::_filter[recursive](this, List<T>@{}, 0, p);
    }

    method ofType<U>(): List<U> {
        return List<T>::_oftype<U>[recursive](this, List<T>@{}, 0);
    }

    method cast<U>(): List<U> {
        return List<T>::_cast<U>[recursive](this, List<U>@{}, 0);
    }

    method slice(start?: Int, end?: Int): List<T> 
        requires release this->_rangeInBounds(start, end);
    {
        let s, e = start ?| 0, end ?| List<T>::_size(this);

        if(s == e) {
            return List<T>@{};
        }
        else {
            return List<T>::_slice[recursive](this, List<T>@{}, s, e);
        }
    }

    method removeFirst(k: Int): List<T> {
        if(k >= List<T>::_size(this)) {
            return List<T>@{};
        }
        else {
            return List<T>::_slice[recursive](this, List<T>@{}, k, List<T>::_size(this));
        }
    }

    method removeLast(k: Int): List<T> {
        if(k >= List<T>::_size(this)) {
            return List<T>@{};
        }
        else {
            return List<T>::_slice[recursive](this, List<T>@{}, 0, List<T>::_size(this) - k);
        }
    }

    method takeWhile(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::_takewhile[recursive](this, List<T>@{}, 0, p);
    }

    method discardWhile(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::_discardwhile[recursive](this, 0, p);
    }

    method takeUntil(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::_takeuntil[recursive](this, List<T>@{}, 0, p);
    }

    method discardUntil(p: recursive? fn(_: T) -> Bool): List<T> {
        return List<T>::_discarduntil[recursive](this, 0, p);
    }

    method {when T KeyType} unique(): List<T> {
        return List<T>::_unique[recursive](this, List<T>@{}, 0);
    }

    method reverse(): List<T> {
        return List<T>::_reverse[recursive](this, List<T>@{}, 0);
    }

    method map<U>(f: recursive? fn(_: T) -> U): List<U> {
        return List<T>::_map[recursive](this, List<U>@{}, 0, f);
    }

    method mapIndex<U>(f: recursive? fn(_: Int, _: T) -> U): List<U> {
        return List<T>::_mapIndex[recursive](this, List<U>@{}, 0, f);
    }

    method {when T KeyType} project<U>(m: IMap<T, U>): List<U> {
        if(m->is<Map<T, U>()) {
            return List<T>::_projectWMap<U>[recursive](this, List<U>@{}, 0, m->as<Map<T, U>>()); 
        }
        else {
            abort;
        }
    }

    method {when T KeyType} tryProject<U>(m: IMap<T, U>): List<U?> {
        if(m->is<Map<T, U>()) {
            return List<T>::_tryProjectWMap<U>[recursive](this, List<U>@{}, 0, m->as<Map<T, U>>());
        }
        else {
            abort;
        }
    }

    method zipIndex(): List<[Int, T]> {
        return List<T>::_zipIndex[recursive](this, List<[Int, T]>@{}, 0);
    }

    method join<U>(ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<[T, U]> {
        return List<T>::_join<U>[recursive](this, ol, List<[T, U]>@{}, 0, p);
    }

    method joinGroup<U>(ol: List<U>, p: recursive? fn(_: T, _: U) -> Bool): List<[T, List<U>]> {
        return List<T>::_joinGroup<U>[recursive](this, ol, List<[T, List<U>]>@{}, 0, p);
    }

    method append(l: List<T>): List<T> {
        let cl = List<T>::_append[recursive](this, List<T>@{}, 0);
        return List<T>::_append[recursive](l, cl, 0);
    }

    method prepend(l: List<T>): List<T> {
        let cl = List<T>::_append[recursive](l, List<T>@{}, 0);
        return List<T>::_append[recursive](this, cl, 0);
    }

    method partition<K where K KeyType>(pf: recursive? fn(_: T) -> K): Map<K, List<T>> {
        return List<T>::_partition<K>[recursive](this, Map<K, List<T>>@{}, 0, pf);
    }

    method sort(cmp: recursive? fn(_: T, _: T) -> Bool): List<T> {
        return List<T>::_sort[recursive](this, List<T>@{}, 0, pf);
    }

    method toMap<K where K KeyType, V>(kf: recursive? fn(_: T) -> K, vf: recursive? fn(_: T) -> V): Map<K, V> {
        return List<T>::_toMap<K, V>[recursive](this, Map<K, V>@{}, 0, kf, vf);
    }

    method toIndexMap<V>(vf: recursive? fn(_: Int, _: T) -> V): Map<Int, V> {
        return List<T>::_toIndexMap<K, V>[recursive](this, Map<K, V>@{}, 0, vf);
    }
}

concept ListUtil {
    hidden recursive static _zip<T>(l1: List<T>, l2: List<U>, lp: List<[T, U]>, idx: Int): List<[T, U]> {
        if(idx == List<T>::_size(l1)) {
            return lp;
        }
        else {
            let vt = List<T>::_unsafe_get(l1, idx);
            let vu = List<U>::_unsafe_get(l2, idx);
            return ListUtil::_zip(l1, l2, List<[T, U]>::_unsafe_push(lp, [vt, vu]), idx + 1);
        }
    }

    hidden recursive static _unzip<T>(l: List<[T, U]>, lt: List<T>, lu: List<U>, idx: Int): List<T>, List<U> {
        if(idx == List<T>::_size(l)) {
            return lt, lu;
        }
        else {
            let vp = List<[T, U]>::_unsafe_get(l, idx);
            return ListUtil::_unzip(l, List<T>::_unsafe_push(lt, vp.0), List<U>::_unsafe_push(lu, vp.1), idx + 1);
        }
    }

    hidden recursive static _concat<T>(l: List<List<T>>, lp: List<T>, idx: Int): List<T> {
        if(idx === List<T>_size(l)) {
            return lp;
        }
        else {
            let ll = List<List<T>>::_unsafe_get(l, idx);
            let cc = List<T>::_append(ll, lp, 0);
            return List<T>::_concat(l, lp, idx + 1);
        }
    }

    hidden recursive static _fill<T>(k: Int, val: T, lp: List<T>): List<T> {
        if(k == 0) {
            return lp;
        }
        else {
            return ListUtil::_fill[recursive](k - 1, List<Int>::_unsafe_push(lp, val));
        }
    }

    hidden recursive static _fillIndex(k: Int, lp: List<Int>, idx: Int): List<Int> {
        if(idx == k) {
            return lp;
        }
        else {
            return ListUtil::_fillIndex[recursive](k, List<Int>::_unsafe_push(lp, idx), idx + 1);
        }
    }

    hidden recursive static _range(start: Int, end: Int, lp: List<Int>): List<Int> {
        if(start == end) {
            return lp;
        }
        else {
            return ListUtil::_range[recursive](start + 1, end, List<Int>::_unsafe_push(lp, start));
        }
    }

    static zip<T>(l1: List<T>, l2: List<U>): List<[T, U]>
        requires release List<T>::_size(l1) == List<U>::_size(l2);
    {
        return ListUtil::_zip<T>[recursive](l1, l2, List<[T, U]>@{}, 0);
    }

    static unzip<T, U>(l: List<[T, U]>): List<T>, List<U> {
        return ListUtil::_unzip<T>[recursive](l, List<T>@{}, List<U>@{}, 0);
    }

    static concat<T>(...ll: List<List<T>>): List<T> {
        return ListUtil::_concat[recursive](ll, List<T>@{}, 0);
    }

    static fill<T>(k: Int, val: T): List<T> {
        return ListUtil::_fill<T>[recursive](k, val, List<T>@{});
    }

    static fillIndex(k: Int): List<Int> {
        return ListUtil::_fillIndex[recursive](k, List<Int>@{}, 0);
    }

    static range(start: Int, end: Int): List<Int>  {
        return ListUtil::_range[recursive](start, end, List<Int>@{});
    }
}
