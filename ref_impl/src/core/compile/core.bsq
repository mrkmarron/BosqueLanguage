//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the fluent core language
namespace NSCore;

//<summary>The special concept which all values are instances of.</summary>
concept Any {
    method is<T>(): Bool # special_method
    method as<T>(): T # special_method

    method tryAs<T>(): T? # special_method
    method defaultAs<T>(default: T): T # special_method

    method isNone(): Bool # special_method
    method isSome(): Bool # special_method
}

//<summary>Type for representing all non-none values.</summary>
concept Some provides Any {
    method update(): Some # special_method
    method merge(): Some # special_method
    method project<T>(): Some # special_method
}

//<summary>Type for representing the none-value.</summary>
concept Truthy provides Any {
}

//<summary>Type for representing the none-value.</summary>
entity None provides Any, Truthy {
}

concept Parsable provides Some {
    abstract static tryParse(str: String): Some | None;
}

//<summary>Primitive boolean value.</summary>
entity Bool provides Truthy, Parsable {
    override static tryParse(str: String): Some | None {
        return Bool::tryParseAs(str);
    }

    static tryParseAs(str: String): Bool | None {
        if(str == "true") {
            return true;
        }
        elif(str == "false") {
            return false;
        }
        else {
            return none;
        }
    }
}

//<summary>Primitive integer value.</summary>
entity Int provides Parsable {
    override static tryParse(str: String): Some | None {
        return Int::tryParseAs(str);
    }

    static tryParseAs(str: String): Int | None # int_tryparse

    static max(v1: Int, v2: Int): Int {
        return v1 > v2 ? v1 : v2;
    }

    static min(v1: Int, v2: Int): Int {
        return v1 < v2 ? v1 : v2;
    }
}

//<summary>Primitive string value.</summary>
entity String provides Some {
}

concept StringOf provides Some {
    abstract method getString(): String;
}

entity StringOf<T where Parsable> provides StringOf {
}

//<summary>Primitive GUID value.</summary>
entity GUID provides Some {
}

//<summary>Primitive regex value.</summary>
entity Regex provides Some, Parsable {
    override static tryParse(str: String): Some | None # regex_tryparse

    method match(str: String, start?: Int, end?: Int): { start: Int, end: Int } | None # regex_match

    //
    //TODO: this is pretty boring right now
    //
}

//<summary>All actual tuples implicitly provide this concept.</summary>
concept Tuple provides Some {
}

//<summary>All actual records implicitly provide this concept.</summary>
concept Record provides Some {
}

//<summary>All actual entities/concepts implicitly provide this concept.</summary>
concept Object provides Some {
}

//<summary>All actual enums implicitly provide this.</summary>
concept Enum provides Some {
}

//<summary>All actual custom keys implicitly provide this.</summary>
concept IdKey provides Some {
}

//<summary>Types that can be used as equality based keys.</summary>
typedef KeyType = None | Bool | Int | String | StringOf | GUID | Enum | Tuple | Record | IdKey;

//<summary>Concept that all Keyed instances inherit from.</summary>
concept Keyed provides Some {
    abstract method getKey(): KeyType;
}

//<summary>Providing this concept allows for an entity to be compared or stored in a key based container using the key field.</summary>
concept Keyed<T where KeyType> provides Keyed {
    field key: T;

    override method getKey(): KeyType {
        return this.key;
    }
}

//<summary>Types that can be used in equality operations or in key based containers.</summary>
typedef Indexable = KeyType | Keyed;

//<summary>Concept that all Tagged instances inherit from.</summary>
concept Tagged provides Some, Keyed {
    abstract method getValue(): Any;
}

//<summary>A lightweight tagging class for values.</summary>
entity Tagged<T where KeyType, U> provides Tagged {
    field value: U;

    override method getValue(): Any {
        return this.value;
    }
}

//<summary>Shorthand for predicate function types.</summary>
typedef Predicate<T> = fn(_: T) -> Bool;

//<summary>Shorthand for transform function types.</summary>
typedef Transform<T, U> = fn(_: T) -> U;
