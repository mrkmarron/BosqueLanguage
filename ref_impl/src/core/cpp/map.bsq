//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity Map<K where KeyType, V> provides Object, Expandoable<MapEntry<K, V>>, PODType when K PODType && V PODType, APIType when K APIType && V APIType {
    hidden static _size(m: Map<K, V>): Int # map_size
    hidden static _has_key(m: Map<K, V>, key: K): Bool # map_has_key
    hidden static _at_val(m: Map<K, V>, key: K): V # map_at_val

    hidden static _key_list(m: Map<K, V>): List<K> # map_key_list
    hidden static _key_set(m: Map<K, V>): Set<K> # map_key_set
    hidden static _values(m: Map<K, V>): List<V> # map_values
    hidden static _entries(m: Map<K, V>): List<MapEntry<K, V>> # map_entries

    hidden static _has_all(m: Map<K, V>, kl: List<K>): Bool # map_has_all
    hidden static _domainincludes(m: Map<K, V>, s: Set<K>): Bool # map_domainincludes

    recursive? hidden static _submap(m: Map<K, V>, p: recursive? fn(_: K, _: V) -> Bool): Map<K, V> # map_submap
    hidden static _oftype<T where KeyType, U>(m: Map<K, V>): Map<T, U> # map_oftype
    hidden static _cast<T where KeyType, U>(m: Map<K, V>): Map<T, U> # map_cast

    hidden static _project(m: Map<K, V>, ds: Set<K>, missingok: Bool): Map<K, V> # map_project
    hidden static _exclude(m: Map<K, V>, ds: Set<K>): Map<K, V> # map_exclude

    recursive? hidden static _remap(m: Map<K, V>, f: recursive? fn(_: K, _: V) -> U): Map<K, U> # map_remap

    hidden static _projectall(m: Map<K, V>, dl: List<K>): Map<K, V> # map_projectall
    hidden static _excludeall(m: Map<K, V>, ds: Set<K>): Map<K, V> # map_excludeall

    hidden static _union(m: Map<K, V>, om: Map<K, V>): Map<K, V> # map_union
    hidden static _unionall(dl: List<Map<K, V>>): Map<K, V> # map_unionall

    hidden static _merge(m: Map<K, V>, om: Map<K, V>): Map<K, V> # map_merge
    hidden static _mergeall(dl: List<Map<K, V>>): Map<K, V> # map_mergeall

    override method size(): Int {
        return Map<K, V>::_size(this);
    }

    override method empty(): Bool {
        return Map<K, V>::_size(this) == 0;
    }

    override method keys(): List<K> {
        return Map<K, V>::_key_list(this);
    }

    override method keySet(): Set<K> {
        return Map<K, V>::_key_set(this);
    }

    override method values(): List<K> {
        return Map<K, V>::_values(this);
    }

    override method entries(): List<MapEntry<K, V>> {
        return Map<K, V>::_entries(this);
    }

    method toDynamicMap(): DynamicMap<K, V> {
        abort;
    }

    override method has(key: K): Bool {
        return Map<K, V>::_has_key(this, k)
    }

    override method hasAll(...kl: List<K>): Bool {
        return Map<K, V>::_has_all(this, kl);
    }

    override method domainIncludes(s: Set<K>): Bool {
        if(Set<K>::_size(s) > Map<K, V>::_size(this)) {
            return false;
        }
        else {
            return Map<K, V>::_domainincludes(this, s);
        }
    }

    override method get(key: K): V 
        requires release Map<K, V>::_has_key(this, k);
    {
        return Map<K, V>::_at_val(this, k);
    }

    override method tryGet(k: K): V? {
        return Map<K, V>::_has_key(this, k) ? Map<K, V>::_at_val(this, k) : none;
    }

    recursive? method submap(p: recursive? fn(_: K, _: V) -> Bool): Map<K, V> {
        return Map<K, V>::_submap[recursive?](this, p);
    }

    method ofType<T where KeyType, U>(): Map<T, U> {
        return Map<K, V>::_oftype<U>(this);
    }

    method cast<T where KeyType, U>(): Map<T, U> {
        return Map<K, V>::_cast<U>(this);
    }

    method project(ds: Set<K>, missingok?: Bool): Map<K, V> {
        return Map<K, V>::_project(this, ds, Truthy::truth(missingok));
    }

    method exclude(ds: Set<K>): Map<K, V> {
        return Map<K, V>::_exclude(this, ds);
    }

    recursive? method remap<U>(f: recursive? fn(_: K, _: V) -> U): Map<K, U> {
        return Map<K, V>::_remap<U>[recursive?](this, f);
    }

    method projectAll(...kl: List<K>): Map<K, V> {
        return Map<K, V>::_projectall(this, kl);
    }

    method excludeAll(...kl: List<K>): Map<K, V> {
        return Map<K, V>::_excludeall(this, kl);
    }

    method union(m: Map<K, V>): Map<K, V> {
        return Map<K, V>::_union[](this, s);
    }

    static unionOf(...ml: List<Map<K, V>>): Map<K, V> {
        if(List<T>::_size(ml) == 0) {
            return Map<K, V>@{};
        }
        elif(List<T>::_size(ml) == 1) {
            return List<T>::_unsafe_get(ml, 0);
        }
        else {
            return Set<T>::_unionall(ml);
        }
    }

    method merge(m: Map<K, V>): Map<K, V> {
        return Map<K, V>::_merge(this, s);
    }

    static mergeOf(...ml: List<Map<K, V>>): Map<K, V> {
        if(List<T>::_size(ml) == 0) {
            return Map<K, V>@{};
        }
        elif(List<T>::_size(ml) == 1) {
            return List<T>::_unsafe_get(ml, 0);
        }
        else {
            return Set<T>::_mergeall(ml);
        }
    }
}

entity DynamicMap<K where KeyType, V> provides Object, Expandoable<MapEntry<K, V>> {
    override method size(): Int {
        abort;
    }

    override method empty(): Bool  {
        abort;
    }

    override method keys(): List<K>  {
        abort;
    }

    override method keySet(): Set<K>  {
        abort;
    }

    override method values(): List<K>  {
        abort;
    }

    override method entries(): List<MapEntry<K, V>>  {
        abort;
    }

    method toMap(): DynamicMap<K, V> {
        abort;
    }

    override method has(key: K): Bool {
        abort;
    }

    override method hasAll(...ks: List<K>): Bool {
        abort;
    }

    override method domainIncludes(s: Set<K>): Bool {
        abort;
    }

    override method get(key: K): V {
        abort;
    }

    override method tryGet(k: K): V? {
        abort;
    }

    method add(k: K, v: V): DynamicMap<K, V> {
        abort;
    }

    method addAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method insert(k: K, v: V): DynamicMap<K, V> {
        abort;
    }

    method insertAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method update(k: K, v: V): DynamicMap<K, V> {
        abort;
    }

    method updateAll(...el: List<MapEntry<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method remove(k: K): DynamicMap<K, V> {
        abort;
    }

    method removeAll(...kl: List<K>): DynamicMap<K, V> {
        abort;
    }

    recursive? method submap(p: recursive? fn(_: K, _: V) -> Bool): DynamicMap<K, V> {
        abort;
    }

    method ofType<T where KeyType, U>(): Map<T, U> {
        abort;
    }

    method cast<T where KeyType, U>(): Map<T, U> {
        abort;
    }

    method project(ds: Set<K>, missingok?: Bool): DynamicMap<K, V> {
        abort;
    }

    method exclude(ds: Set<K>): Map<K, V> {
        abort;
    }

    recursive? method remap<U>(f: recursive? fn(_: K, _: V) -> U): DynamicMap<K, U> {
        abort;
    }

    method projectAll(...kl: List<K>): DynamicMap<K, V> {
        abort;
    }

    method excludeAll(...kl: List<K>): DynamicMap<K, V> {
        abort;
    }

    method unionWith(m: Map<K, V>): DynamicMap<K, V> {
        abort;
    }

    static union(...ml: List<Map<K, V>>): DynamicMap<K, V> {
        abort;
    }

    method mergeWith(m: Map<K, V>): DynamicMap<K, V> {
        abort;
    }

    static merge(...ml: List<Map<K, V>>): DynamicMap<K, V> {
        abort;
    }
}


