//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

//The core namespace implements the primitive concepts used in the bosque core language
namespace NSCore;

entity Set<T where KeyType> provides Object, Expandoable<T>, PODType when T PODType, APIType when T APIType {
    hidden static _size(s: Set<T>): Int # set_size

    hidden static _entry_list(s: Set<T>): List<T> # set_entry_list

    hidden static _has_key(s: Set<T>, v: T): Bool # set_has_key
    hidden static _hasall(s: Set<T>, l: List<T>): Bool # set_hasall
    
    hidden static _subsetof(s: Set<T>, os: Set<T>): Bool # set_subsetof
    hidden static _equal(s: Set<T>, os: Set<T>): Bool # set_equal
    hidden static _disjoint(s: Set<T>, os: Set<T>): Bool # set_disjoint

    recursive? hidden static _subset(s: Set<T>, p: recursive? fn(_: T) -> Bool): Set<T> # set_subset
    hidden static _oftype<U where KeyType>(s: Set<T>): Set<U> # set_oftype
    hidden static _cast<U where KeyType>(s: Set<T>): Set<U> # set_cast

    hidden static _union(s: Set<T>, os: Set<T>): Set<T> # set_union
    hidden static _intersect(s: Set<T>, os: Set<T>): Set<T> # set_intersect
    hidden static _difference(s: Set<T>, os: Set<T>): Set<T> # set_difference
    hidden static _symmetricdifference(s: Set<T>, os: Set<T>): Set<T> # set_symmetricdifference

    hidden static _unionall(sl: List<Set<T>>): Set<T> # set_unionall
    hidden static _intersectall(sl: List<Set<T>>): Set<T> # set_intersectall

    override method size(): Int {
        return Set<T>::_size(this);
    }

    override method empty(): Bool {
        return Set<T>::_size(this) == 0;
    }

    override method entries(): List<T> {
        return Set<T>::_entry_list(this);
    }

    override method has(v: T): Bool {
        return Set<T>::_has_key(this, v);
    }

    override method hasAll(...v: List<T>): Bool {
        return Set<T>::_hasall(this, v);
    }

    method toDynamicSet<T>(): DynamicSet<T> {
        abort;
    }

    method subsetOf(s: Set<T>): Bool {
        return Set<T>::_subsetof(this, s);
    }

    method equal(s: Set<T>): Bool {
        return Set<T>::_equal(this, s);
    }

    method disjoint(s: Set<T>): Bool {
        return Set<T>::_disjoint(this, s);
    }

    recursive? method subset(p: recursive? fn(_: T) -> Bool): Set<T> {
        return Set<T>::_subset[recursive?](this, p);
    }

    method ofType<U where KeyType>(): Set<U> {
        return Set<T>::_oftype<U>(this);
    }

    method cast<U where KeyType>(): Set<U> {
        return Set<T>::_cast<U>(this);
    }

    method union(s: Set<T>): Set<T> {
        return Set<T>::_union(this, s);
    }

    method intersect(s: Set<T>): Set<T> {
        return Set<T>::_intersect(this, s);
    }

    method difference(s: Set<T>): Set<T> {
        return Set<T>::_difference(this, s);
    }

    method symmetricDifference(s: Set<T>): Set<T> {
       return Set<T>::_symmetricdifference(this, s);
    }

    static unionOf(...sl: List<Set<T>>): Set<T> {
        if(List<T>::_size(sl) == 0) {
            return Set<T>@{};
        }
        else if(List<T>::_size(sl) == 1) {
            return List<T>::_unsafe_get(sl, 0);
        }
        else {
            return Set<T>::_unionall(sl);
        }
    }

    static intersectionOf(...sl: List<Set<T>>): Set<T> {
        if(List<T>::_size(sl) == 0) {
            return Set<T>@{};
        }
        else if(List<T>::_size(sl) == 1) {
            return List<T>::_unsafe_get(sl, 0);
        }
        else {
            return Set<T>::_intersectall(sl);
        }
    }
}

entity DynamicSet<T where KeyType> provides Object, Expandoable<T> {
    override method size(): Int {
        abort;
    }

    override method empty(): Bool {
        abort;
    }

    override method entries(): List<T> {
        abort;
    }

    override method has(v: T): Bool  {
        abort;
    }

    override method hasAll(...v: List<T>): Bool  {
        abort;
    }

    method toSet<T>(): Set<T> {
        abort;
    }

    method add(v: T): DynamicSet<T>  {
        abort;
    }

    method addAll(...v: List<T>): DynamicSet<T>  {
        abort;
    }

    method insert(v: T): DynamicSet<T>  {
        abort;
    }

    method insertAll(...v: List<T>): DynamicSet<T>  {
        abort;
    }

    method remove(v: T): DynamicSet<T>  {
        abort;
    }

    method removeAll(...v: List<T>): DynamicSet<T>  {
        abort;
    }

    method subsetOf(s: DynamicSet<T>): Bool  {
        abort;
    }

    method equal(s: DynamicSet<T>): Bool  {
        abort;
    }

    method disjoint(s: DynamicSet<T>): Bool  {
        abort;
    }

    recursive? method subset(p: recursive? fn(_: T) -> Bool): Set<T> {
        abort;
    }

    method ofType<U where KeyType>(): Set<U> {
        abort;
    }

    method cast<U where KeyType>(): Set<U> {
        abort;
    }

    method union(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    method intersect(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    method difference(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    method symmetricDifference(s: DynamicSet<T>): DynamicSet<T>  {
        abort;
    }

    static unionOf(...sl: List<DynamicSet<T>>): DynamicSet<T> {
        abort;
    }

    static intersectionOf(...sl: List<DynamicSet<T>>): DynamicSet<T> {
        abort;
    }
}
