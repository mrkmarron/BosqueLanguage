namespace NSMain;

entity Board {
    const playerX: String = "x";
    const playerO: String = "o";

    const allCellPositions: List<[Int, Int]> = List<[Int, Int]>{
        [ 0, 0 ], [ 1, 0 ], [ 2, 0 ],
        [ 0, 1 ], [ 1, 1 ], [ 2, 1 ],
        [ 0, 2 ], [ 1, 2 ], [ 2, 2 ]
    };

    const winPositionOptions: List<List<[Int, Int]>> = List<List<[Int, Int]>>{
        List<[Int, Int]>{ [ 0, 0 ], [ 0, 1 ], [ 0, 2 ] },
        List<[Int, Int]>{ [ 0, 1 ], [ 1, 1 ], [ 2, 1 ] },
        List<[Int, Int]>{ [ 0, 2 ], [ 1, 2 ], [ 2, 2 ] },

        List<[Int, Int]>{ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ] },
        List<[Int, Int]>{ [ 1, 0 ], [ 1, 1 ], [ 1, 2 ] },
        List<[Int, Int]>{ [ 2, 0 ], [ 2, 1 ], [ 2, 2 ] },

        List<[Int, Int]>{ [ 0, 0 ], [ 1, 1 ], [ 2, 2 ] },
        List<[Int, Int]>{ [ 0, 2 ], [ 1, 1 ], [ 2, 0 ] }
    };

    //Board is a list of marks, indexed by x,y coords from upper left 0 based
    field cells: List<String?>;

    factory static createInitialBoard(): { cells: List<String?> } {
        return { cells=List<String?>{none, none, none, none, none, none, none, none, none} };
    }

    method getOpenCells(): List<[Int, Int]> {
        return Board::allCellPositions->filter(fn(pos: [Int, Int]): Bool => {
            return !this->isCellOccupied(pos.0, pos.1);
        });
    }

    method getCellContents(x: Int, y: Int): String?
        requires 0 <= x && x < 3 && 0 <= y && y < 3;
    {
        return this.cells->at(x + y * 3);
    }

    method isCellOccupied(x: Int, y: Int): Bool {
        return this->getCellContents(x, y) != none;
    }

    method isCellOccupiedWith(x: Int, y: Int, mark: String): Bool
        requires mark == Board::playerX || mark == Board::playerO;
    {
        return this->getCellContents(x, y) == mark;
    }

    method markCellWith(x: Int, y: Int, mark: String): Board
        requires mark == Board::playerX || mark == Board::playerO;
        requires 0 <= x && x < 3 && 0 <= y && y < 3;
        requires !this->isCellOccupied(x, y);
    {
        return this->update(cells=this.cells->set(x + y * 3, mark));
    }

    hidden method checkSingleWinOption(opt: List<[Int, Int]>, mark: String): Bool {
        return opt->all(fn(entry: [Int, Int]): Bool => this->isCellOccupiedWith(entry.0, entry.1, mark));
    }

    hidden method checkSingleWinner(mark: String): Bool {
        return Board::winPositionOptions->any(fn(opt: List<[Int, Int]>): Bool => this->checkSingleWinOption(opt, mark));
    }

    method checkForWinner(): String? {
        if(this->checkSingleWinner(Board::playerX)) {
            return Board::playerX;
        }
        elif(this->checkSingleWinner(Board::playerO)) {
            return Board::playerO;
        }
        else {
            return none;
        }
    }
}

entity Game {
    field winner: String? = none;
    field board: Board = Board@createInitialBoard();

    method hasWinner(): Bool {
        return this.winner != none;
    }

    method getWinner(): String
        requires this->hasWinner();
    {
        return this.winner->as<String>();
    }

    method makeExplicitMove(x: Int, y: Int, mark: String): Game
        requires !this.board->isCellOccupied(x, y);
    {
        var nboard = this.board->markCellWith(x, y, mark);
        return this->update(board=nboard, winner=this.board->checkForWinner());
    }
}

entrypoint function main(x: Int, y: Int): String?
    requires 0 <= x && x < 3;
    requires 0 <= y && y < 2;
{
    var! g = Game{}
    ->makeExplicitMove(x, y, "x")
    ->makeExplicitMove(x, y + 1, "x");

    //if(!g.board->isCellOccupied(0, 2)) {
        g = g->makeExplicitMove(0, 2, "x");
    //}

    return g->hasWinner() ? g->getWinner() : none;
}

/*
(declare-const x Int)
(assert (and (<= 0 x) (< x 3)))
(declare-const y Int)
(assert (and (<= 0 y) (< y 2)))

(declare-const res Result_Bool)
(assert (= res (NSMain$cc$main x y)))

(assert (is-Result_Bool@result_with_code res))
;(assert (is-Result_Bool@result_success res))

(check-sat)
(get-model)
*/

/*
entrypoint function main(x0: Int, y0: Int, x1: Int, y1: Int, x2: Int, y2: Int): Bool {
    var g = Game{board=Board@createInitialBoard()}
    ->makeExplicitMove(x0, y0, "x")
    ->makeExplicitMove(0, 0, "o")
    ->makeExplicitMove(x1, y1, "x")
    ->makeExplicitMove(0, 1, "o")
    ->makeExplicitMove(x2, y2, "x");

    //assert g->getWinner() == Board::playerX;
    assert g->getWinner() == Board::playerO;

    return true;
}

(declare-const x0 Int)
(assert (and (<= 0 x0) (< x0 3)))
(declare-const y0 Int)
(assert (and (<= 0 y0) (< y0 3)))

(declare-const x1 Int)
(assert (and (<= 0 x1) (< x1 3)))
(declare-const y1 Int)
(assert (and (<= 0 y1) (< y1 3)))

(declare-const x2 Int)
(assert (and (<= 0 x2) (< x2 3)))
(declare-const y2 Int)
(assert (and (<= 0 y2) (< y2 3)))

(declare-const res Result_Bool)
(assert (= res (NSMain$cc$main x0 y0 x1 y1 x2 y2)))

;(assert (is-Result_Bool@result_with_code res))
(assert (is-Result_Bool@result_success res))

(check-sat)
(get-model)
*/
