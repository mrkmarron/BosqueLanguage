//-------------------------------------------------------------------------------------------------------
// Copyright (C) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
//-------------------------------------------------------------------------------------------------------

namespace NSTest;

////
//Misc Defs

concept WithName {
    invariant $name != "";

    field name: String;
}

concept Greeting {
    abstract method sayHello(): String;

    virtual method sayGoodbye(): String {
        return "goodbye";
    }
}

entity GenericGreeting provides Greeting {
    const instance: GenericGreeting = GenericGreeting@{};

    override method sayHello(): String {
        return "hello world";
    }
}

entity NamedGreeting provides WithName, Greeting {
    override method sayHello(): String {
        return String::concat("hello", " ", this.name);
    }
}

typedef Letter = /^\w$/;
typedef Digit = /^\d$/;

function fss(s1: SafeString<Digit>): Bool {
    return s1->string() == "3";
}

entity StatusCode provides Parsable {
    field code: Int;
    field name: String;

    override static tryParse(name: String): Result<StatusCode, String> {
        return switch(name) {
            case "IO"      => ok(StatusCode@{1, name})
            case "Network" => ok(StatusCode@{2, name})
            case _         => err("Unknown code")
        };
    }
}

function isIOCode(s: StringOf<StatusCode>): Bool {
    return s == StatusCode'IO';
}

////
//Tests

function add2(x: Int, y: Int): Int {
    return x + y;
}

entrypoint function add2C(): Int {
    return add2(2, 3);
}

entrypoint function add2Check(x: Int): Int {
    return add2(2, x);
}

function allPositive(...args: List<Int>): Bool {
    return args->allof(fn(x) => x >= 0);
}

entrypoint function allPositiveC(): Bool {
    return allPositive(1, 3, 4);
}

entrypoint function allPositiveCheck(x: Int): Bool {
    let b = allPositive(1, 3, x, 4);
    check b;

    return b; 
}

entrypoint function allPositiveCapture(): Bool {
    let zero = 0;
    return List<Int>@{1, 2}->allof(fn(x) => x >= zero);
}

function sign(x?: Int): Int {
    var y: Int;

    if(x == none || x == 0) {
        y = 0;
    }
    else {
        y = (x > 0) ? 1 : -1;
    }

    return y;
}

entrypoint function signC5(): Int {
    return sign(5);
}

entrypoint function signCm5(): Int {
    return sign(-5);
}

entrypoint function signCnone(): Int {
    return sign();
}

entrypoint function signCheck(x: Int): Int {
    let v = sign(x);
    check x != 1;

    return x;
}

function recordtuple(tup: [Int, Bool], rec: {f: String, g: Int}): Int {
    return tup.0 + rec.g;
}

entrypoint function recordtupleC(): Int {
    return recordtuple([1, false], {f="ok", g=3});
}

entrypoint function checkInvsAndObjs(): Bool {
    check GenericGreeting@{}->sayHello() == "hello world";
    check GenericGreeting::instance->sayHello() == "hello world";

    check NamedGreeting@{name="bob"}->sayHello() == "hello bob";

    return true;
}

entrypoint function checkInvsAndObjsFail(): String {
    return NamedGreeting@{name=""}->sayHello();
}

entrypoint function checkInvsAndObjsPuzzle(n: String): String {
    let say = NamedGreeting@{name=(n == "" ? "bob" : n)}->sayHello();
    check say != "hello chuck";

    return say;
}

entrypoint function sstringAccepts(): Bool {
    return !Digit::accepts("a") && Digit::accepts("2");
}

entrypoint function sstringLiteral(): Bool {
    return fss(Digit'3');
}

entrypoint function sstringAsError(): Bool {
    return fss(SafeString<Digit>::from("a"));
}

entrypoint function sstringAsOk(): Bool {
    return fss(SafeString<Digit>::from("3"));
}

entrypoint function sstringAsChk(s: String): Bool {
    if(Digit::accepts(s)) {
        check !fss(SafeString<Digit>::from(s));
    }

    return true;
}

entrypoint function stringofFromErr(): Bool {
    return isIOCode(StringOf<StatusCode>::from("Input"));
}

entrypoint function stringofIsIONo(): Bool {
    return isIOCode(StringOf<StatusCode>::from("Network"));
}

entrypoint function stringofIsIOYes(): Bool {
    return isIOCode(StringOf<StatusCode>::from("IO"));
}

entrypoint function stringofIsIOCons(): Int {
    let sc: StatusCode = StatusCode@'IO';
    return sc.code;
}

entrypoint function stringofIsChk(s: String): Int {
    let sc = StatusCode::tryParse(s);
    if(sc->isOk()) {
        check sc->result().code != 2;
    }

    return 0;
}